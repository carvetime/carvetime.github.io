<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack 07 生产环境]]></title>
    <url>%2F2019%2F06%2F05%2Fjs%2Fwebpack%2Fwebpack-07-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[生产环境和开发环境的配置有部分差异的，生产环境追求打包的代码最小化，开发环境追求调试方便，所以需要souce map，live reload等，通常情况下我们会针对不同环境下编写不同的配置，但是两者之间又存在共同的一些配置，在此我们将使用到 webpack-merge 的工具，我们独立写一份common的配置，然后merge到不同的环境中 首先我们先安装下 webpack-merge1npm install --save-dev webpack-merge 分别创建并配置3个文件 webpack.common.js1234567891011121314151617181920const path = require('path')const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; mode: 'development', entry: &#123; index:'./examples/07/code/src/index.js' &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title: 'Product' &#125;) ], output: &#123; filename: '[name].[contenthash].bundle.js', path: path.resolve(__dirname, 'examples/07/code/dist') &#125;&#125; webpack.dev.js12345678910const merge = require('webpack-merge')const common = require('./webpack.common.js')module.exports = merge(common,&#123; mode: 'development', devtool: 'inline-source-map', devServer: &#123; contentBase: './examples/07/code/dist/' &#125;&#125;) webpack.prod.js123456const merge = require('webpack-merge')const common = require('./webpack.common.js')module.exports = merge(common,&#123; mode: 'production'&#125;) 然后配置下package.json（这里只展示配置的部分代码）123456&#123; "scripts": &#123; "start": "webpack-dev-server --open --config webpack.dev.js", "build": "webpack --config webpack.prod.js" &#125;&#125; 最后通过通过命令行执行不同环境的脚本12345# 开发环境npm run start# 生产环境npm run build github代码]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 06 tree shaking]]></title>
    <url>%2F2019%2F06%2F05%2Fjs%2Fwebpack%2Fwebpack-06-tree-shaking%2F</url>
    <content type="text"><![CDATA[Tree shaking 是webpack是借鉴于rollup的无用代码移除的概念，只有在product环境下时候webpack才会使用tree shaking机制，以此达到最大的优化缩减代码体积。 我们首先创建一个test.js文件，里面包含两个方法 1234567export function test1()&#123; console.log("test1")&#125;export function test2()&#123; console.log("test2")&#125; 然后在index.js里面调用test.js的其中一个test1方法123import &#123;test1&#125; from './test'test1() 配置下简单webpack.config.js文件123456789101112131415161718192021const path = require('path')const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; mode: "development", entry: &#123; index:'./examples/06/code/src/index.js' &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title: 'tree shaking' &#125;) ], output: &#123; filename: '[name].[contenthash].bundle.js', path: path.resolve(__dirname, 'examples/06/code/dist') &#125;&#125; 然后run一下看看打包结果1npm run build 查看下dist/index.哈希值.bundle文件中代码 12345678// 精简后的代码eval(&quot;__webpack_require__.d(__webpack_exports__, \&quot;test1\&quot;, function() &#123; return test1; &#125;);__webpack_require__.d(__webpack_exports__, \&quot;test2\&quot;, function() &#123; return test2; &#125;);function test1()&#123;\n console.log(\&quot;test1\&quot;)\n&#125;function test2()&#123;\n console.log(\&quot;test2\&quot;)\n&#125;//# sourceURL=webpack:///./examples/06/code/src/test.js?&quot;); 我们发现这里面只有test1和test2方法，test2方法我们并没有实际使用，但是还是打包进来了 接下来我们修改下webpack.config.js的打包环境123module.exports = &#123; mode: &quot;production&quot;,&#125; 再run一下再查看下dist/index.哈希值.bundle文件中代码 12// 精简后的部分代码return r.d(t,&quot;a&quot;,t),t&#125;,r.o=function(e,t)&#123;return Object.prototype.hasOwnProperty.call(e,t)&#125;,r.p=&quot;&quot;,r(r.s=0)&#125;([function(e,t,r)&#123;&quot;use strict&quot;;r.r(t),console.log(&quot;test1&quot;)&#125;]); 我们发现这里面只有test1方法，并没有发现test2方法，说明在生产环境下无用代码没有被打包进来。 看上去只要我们直接生产环境打包就tree shaking就会自动删除无用代码，但tree shaking还是存在局限和不足，比如在某些情况下不能做到完全移除无用代码的情况，以及它建立在静态语法分析的基础上，需要确保代码没有使用或编译成CommonJS模块，这个留到后期再进一步解析。 github代码]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 05 缓存]]></title>
    <url>%2F2019%2F06%2F04%2Fjs%2Fwebpack%2Fwebpack-05-%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[浏览器去服务器下载资源是比较耗时操作，为此浏览器都有个缓存机制，根据文件路径名称否变化去决定是否使用本地缓存，从而减少不必要的远端请求，那么此时就需要我们每次在deploy的服务器的时候，需要有个文件命名输出策略。 接下来我们一步步看下，我们的缓存输出策略的衍变 通过配置 output 输出文件名webpack.config.js12345678910111213141516171819const path = require('path')const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; index:'./examples/05/code/src/index.js' &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title: 'Caching' &#125;), ], output: &#123; filename: '[name].[contenthash].bundle.js', path: path.resolve(__dirname, 'examples/05/code/dist') &#125;&#125; 运行下脚本12345678npm run build...Built at: 06/04/2019 11:40:10 AM Asset Size Chunks Chunk Namesindex.3d1cf78a2f957c55fdd2.bundle.js 70.4 KiB 0 [emitted] index index.html 205 bytes [emitted] Entrypoint index = index.3d1cf78a2f957c55fdd2.bundle.js... 我们稍微修改了src/index.js文件的内容,然后再run一下1234567...Built at: 06/04/2019 11:54:39 AM Asset Size Chunks Chunk Namesindex.f9767fa8b88847641fa6.bundle.js 70.4 KiB 0 [emitted] index index.html 205 bytes [emitted] Entrypoint index = index.f9767fa8b88847641fa6.bundle.js... bundle的哈希值是有变化，因为bundle包含了引用的vender文件，所以相当于每次改动bundle一点代码，就会重新引用一遍vender库文件，这样势必导致浏览器延长加载时长。 提取模板为了进一步改善优化webpack的缓存方案，提取模块会将共用的vender模块代码摘取出来，做到和业务代码的有效分离，一遍修改业务代码时，不影响vender的代码的缓存，我们稍微再修改下配置 webpack.config.js123456789101112131415161718192021222324252627282930313233const path = require('path')const webpack = require('webpack');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; index:'./examples/05/code/src/index.js', print: './examples/05/code/src/print.js' &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title: 'Caching' &#125;), ], output: &#123; filename: '[name].[contenthash].bundle.js', path: path.resolve(__dirname, 'examples/05/code/dist') &#125;, optimization:&#123; runtimeChunk: 'single', splitChunks:&#123; cacheGroups:&#123; vendor:&#123; test: /[\\/]node_modules[\\/]/, name: 'vendors', chunks: 'all' &#125; &#125; &#125; &#125;&#125; 这时候我们在run一次12345678910npm run build...Built at: 06/04/2019 3:08:43 PM Asset Size Chunks Chunk Names index.9fef7a7c6b56b8c1f5ee.bundle.js 230 bytes 1 [emitted] index index.html 458 bytes [emitted] print.718d4b2cf1f46b8669a4.bundle.js 181 bytes 2 [emitted] printruntime.fcfdsfa7dfds7wqefed.bundle.js 1.42 KiB 0 [emitted] runtimevendors.4c03bd33715510606f13.bundle.js 69.4 KiB 3 [emitted] vendors... 显然多出来了runtime和vendors的bundle代码，我再稍微看下打包出来的index文件里面也已经不包含vender的代码拉，这时候我们修改index里面的业务代码应该只会修改index的哈希值，我们稍微修改下element.innerHTML = _.join([&#39;缓存&#39;,&#39;机制8&#39;])来验证下 12345678910run run build ...Built at: 06/04/2019 3:14:39 PM Asset Size Chunks Chunk Names index.ff90502fc5bb7df67079.bundle.js 230 bytes 1 [emitted] index index.html 458 bytes [emitted] print.718d4b2cf1f46b8669a4.bundle.js 181 bytes 2 [emitted] printruntime.fcfdsfa7dfds7wqefed.bundle.js 1.42 KiB 0 [emitted] runtimevendors.4c03bd33715510606f13.bundle.js 69.4 KiB 3 [emitted] vendors... 对比发现确实只有index.ff90502fc5bb7df67079.bundle.js文件哈希值变啦。 到这里的话应该缓存的衍化过程应该差不多了，但是还存在一种引入模块的情况需要考虑，我们来看下比如在index.js里面新引入一个print.js文件 src/print.js123export default function print(text)&#123; console.log(text)&#125; src/index.js 1234567import _ from 'lodash'import print from './print'const element = document.createElement('div')element.innerHTML = _.join(['缓存','机制8'])print("hello")document.body.appendChild(element) run一次看下信息12345678910npm run build...Built at: 06/04/2019 3:20:01 PM Asset Size Chunks Chunk Names index.405aec4d016a32b6164a.bundle.js 377 bytes 1, 2 [emitted] index index.html 458 bytes [emitted] print.3993c439110c8a92b7cb.bundle.js 179 bytes 2 [emitted] printruntime.fc9b88b3a7557471c20d.bundle.js 1.42 KiB 0 [emitted] runtimevendors.9e03bed8e5b636aca9c6.bundle.js 69.4 KiB 3 [emitted] vendors... 对比发现index、vender、runtime文件都改变了，我们只是引入了一个新的模块文件，vender是没有任何内容修改的，所以vender的哈希值改变，肯定不是我们想要的，此时我们将环境配置为development时，webpack会给我内部做优化处理，不会修改vender的哈希值，但是生产环境还是需要我们进一步配置 webpack.config.js1234567891011121314151617181920212223242526272829303132333435const path = require('path')const webpack = require('webpack');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; // mode: 'development', entry: &#123; index:'./examples/05/code/src/index.js', print: './examples/05/code/src/print.js' &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title: 'Caching' &#125;), new webpack.HashedModuleIdsPlugin() ], output: &#123; filename: '[name].[contenthash].bundle.js', path: path.resolve(__dirname, 'examples/05/code/dist') &#125;, optimization:&#123; runtimeChunk: 'single', splitChunks:&#123; cacheGroups:&#123; vendor:&#123; test: /[\\/]node_modules[\\/]/, name: 'vendors', chunks: 'all' &#125; &#125; &#125; &#125;&#125; 新增的new webpack.HashedModuleIdsPlugin()插件对生产环境的模块的修改做优化处理，此时我们再run一次发现，vender模块还是保持原样。 github代码]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 04 代码分离]]></title>
    <url>%2F2019%2F06%2F03%2Fjs%2Fwebpack%2Fwebpack-04-%E4%BB%A3%E7%A0%81%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[实际开发中我们会生成多个文件或者多个文件引用某个共用组件，打包的时候不可能全部打包到一个bundle里面，webpack通常有三种方式 入口配置这是一种简单直观的代码分离方式，我们来看下以下配置 webpack.config.js1234567891011121314151617181920const path = require('path')const webpack = require('webpack')const HTMLWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; mode: 'development', entry: &#123; index: './examples/04/code/src/index.js', another: './examples/04/code/src/another-module.js', &#125;, plugins: [ new HTMLWebpackPlugin(&#123; title: 'Code Splitting' &#125;), ], output: &#123; filename: '[name]-bundle.js', path: path.resolve(__dirname, 'examples/04/code/dist') &#125;&#125; src/another-module.js123import _ from 'lodash'console.log(_join(['load','another','module'])) src/index.js12345import _ from 'lodash'const div = document.createElement('div')div.innerText = _join(['load','index'])document.body.appendChild(div) 然后我们在终端run打包看下123456npm run build#生成的文件是#Built at: 06/03/2019 11:29:02 AM# Asset Size Chunks Chunk Names#another-bundle.js 551 KiB another [emitted] another#index-bundle.js 551 KiB index [emitted] index 我们会发现文件size还是比较大，然后查看里面代码，两个文件都都copy了一份lodash的代码，所以导致文件体积过大。 防止重复为了让防止代码重复copy和不够灵活的问题，webpack内置了optimization.splitChunks 方法去提取分离重复的代码,我们来看下以下配置 webpack.config.js12345678910111213141516171819202122232425const path = require('path')const webpack = require('webpack')const HTMLWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; mode: 'development', entry: &#123; index: './examples/04/code/src/index.js', another: './examples/04/code/src/another-module.js', &#125;, plugins: [ new HTMLWebpackPlugin(&#123; title: 'Code Splitting' &#125;), ], optimization: &#123; splitChunks: &#123; chunks: 'all' &#125; &#125;, output: &#123; filename: '[name]-bundle.js', path: path.resolve(__dirname, 'examples/04/code/dist') &#125;&#125; 此时再重新build一次12345678npm run build#生成的文件是# Built at: 06/03/2019 11:36:26 AM#A sset Size Chunks Chunk Names# another-bundle.js 6.98 KiB another [emitted] another# index-bundle.js 6.99 KiB index [emitted] index# index.html 333 bytes [emitted] # vendors~another~index-bundle.js 547 KiB vendors~another~index [emitted] vendors~another~index 通过打包信息以及生产的文件代码我们可以看出，内置的optimization.splitChunks方法将lodash分离成一份共用代码，这样代码就显得灵活和不累赘重复啦，另外针对其他类型的代码分离，可使用mini-css-extract-plugin bundle-loader promise-loader 插件对css 和 bundle 进行防重分离，在此不一一示例。 动态导入动态导入的方法与防重复的方法有些类似，也是会对共用代码进行提取分离，不同之处是，动态导入方法是按需懒加载加载，只有在动态运行时才加载依赖相关代码 webpack.config.js123456789101112const path = require('path')module.exports = &#123; mode: 'development', entry: &#123;inde:'./examples/04/code/src/index.js'&#125;, output: &#123; filename: '[name].bundle.js', chunkFilename: '[name].bundle.js', path: path.resolve(__dirname, 'examples/04/code/dist') &#125;&#125; src/index.js1234567891011function getComponent()&#123; return import('lodash').then((&#123;default: _&#125;) =&gt;&#123; const element = document.createElement('div') element.innerHTML = _.join(['Hello','Webpack']) return element &#125;).catch(error =&gt; 'load lodash error')&#125;getComponent().then(component =&gt; &#123; document.body.appendChild(component)&#125;) 重新打包一次12345npm run build# Built at: 06/03/2019 6:19:34 PM# Asset Size Chunks Chunk Names# 0.bundle.js 547 KiB 0 [emitted] # inde.bundle.js 8.92 KiB inde [emitted] inde 查看下生成的dist/index.bundle.js文件1eval("// import _ from 'lodash' 省略其中中间代码") 可见是在执行getComponent方法时候动态调用的import _ from ‘lodash’方法 此外，我们还可以使用 async functions对此方法进行简化,如下 12345678910async function getComponent()&#123; const &#123;default: _&#125; = await import('lodash') const element = document.createElement('div') element.innerHTML = _.join(['Hello','Webpack']) return element&#125;getComponent().then(component =&gt; &#123; document.body.appendChild(component)&#125;) github代码]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 03 开发环境]]></title>
    <url>%2F2019%2F06%2F03%2Fjs%2Fwebpack%2Fwebpack-03-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[webpack支持三种自定编译方式 观察模式这是webpack自带的自动编译模式，只需在package.json中配置 123"scripts": &#123; "watch": "webpack --watch"&#125; 然后终端输入命令行开启观察者模式1npm run watch 此时只要文件改动，代码将会重新编译，不过需要手动刷新浏览器。 webpack-dev-server首先需要先npm安装下1npm install --save-dev webpack-dev-server 然后配置webpack.config.js，告诉本地开发服务器在哪查找文件123devServer: &#123; contentBase: './examples/03/code/dist/'&#125; 接着我们在package.json里面配置下启动的script脚本123"scripts": &#123; "devserver": "webpack-dev-server --open"&#125; 最后在终端运行1npm run devserver 此时会开启一个浏览器页面，修改了index.js文件后也会同步更新 本地服务器会将编译后的文件存在服务器内存中，不会写入任何编译后的文件到本地磁盘，如果想看到编译后的文件，可以配置一个publicPath，并在该目录下查看。 webpack-dev-middlewarewebpack-dev-middleware，可以结合express server进行更多的自定义配置 首先我们安装下express 和 webpack-dev-middleware1npm install --save-dev express webpack-dev-middleware 接着配置webpack.config.js12345678910111213141516171819const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; mode: 'development', entry: './examples/03/code/src/index.js', plugins: [ new HtmlWebpackPlugin(&#123; title: 'Output Management' &#125;) ], output: &#123; filename: 'bundle.js', path: path.resolve(__dirname,'/examples/03/code/dist'), publicPath: '/' &#125;&#125; 然后创建一个server.js文件123456789101112131415const express = require('express')const webpack = require('webpack')const webpackDevMiddleWare = require('webpack-dev-middleware')const app = express()const config = require('../../../webpack.config.js')const compiler = webpack(config)app.use(webpackDevMiddleWare(compiler,&#123; publicPath: config.output.publicPath&#125;))app.listen(3000,function()&#123; console.log("app listening on port 3000")&#125;) 最后终端执行1node ./examples/03/code/server.js github代码]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 02 资源管理]]></title>
    <url>%2F2019%2F06%2F03%2Fjs%2Fwebpack%2Fwebpack-02-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[webpack除了支持javascript外，还支持通过loader处理其他类型文件 加载CSS先安装并添加 style-loader 和 css-loader1npm install --save-dev style-loader css-loader 然后配置webpack.config.js,通过正则来匹配需要处理的css文件1234567891011121314151617181920const path = require('path')module.exports = &#123; entry: './examples/02/code/src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'examples/02/code/dist') &#125;, module: &#123; rules:[ &#123; test: /style.css$/, use: [ 'style-loader', 'css-loader' ] &#125; ] &#125;&#125; 加载图片先安装并添加 file-loader1npm install --save-dev file-loader 然后配置webpack.config.js,通过正则来匹配需要处理的文件12345678910111213141516171819const path = require('path')module.exports = &#123; entry: './examples/02/code/src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'examples/02/code/dist') &#125;, module: &#123; rules:[ &#123; test: /png$/, use: [ 'file-loader' ] &#125; ] &#125;&#125; 此外还有 csv-loader xml-loader 分别支持导入CSV、TSV 和 XML等资源文件，再此不一一例举。 github代码]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 01 起步]]></title>
    <url>%2F2019%2F06%2F03%2Fjs%2Fwebpack%2Fwebpack-01-%E8%B5%B7%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[先初步使用下webpack 安装终端创建一个工程文件，用npm配置webpack1234mkdir demonpm install -ynpm install webpack --save-devnpm install webpack-cli --save-dev 工程文件我们来对比下传统和webpack的文件引用方式 传统方式dist/index.html123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;Getting Started&lt;/title&gt; &lt;script src="https://unpkg.com/lodash@4.16.6"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="./src/index.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; src/index.js1234567function component()&#123; const element = document.createElement('div') element.innerHTML = _.join(['Hello', 'webpack']) return element;&#125;document.body.append(component()) 这时候直接浏览器打开 dist/index.html 文件我们会正常显示div的标签，但是这样方式很多明显不足 不能立即体现，index.js的文件隐式依赖 本页面script脚本引入 如果依赖下载失败或出错就会导致整个程序无法运行 如果没有使用，就造成不必要的下载 webpack的引用方式基于传统方式的各种不足，我们可以对比衍变出来的webpack的方式的优势12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;Getting Started&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 使用webpack根据./src/index.js文件打包压缩后的文件成bounde.js，并放在dist文件夹下和index.html同级，因此html直接引用打包压缩后的bounde.js文件 --&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 然后我们通过命令行执行1./node_modules/.bin/webpack --config webpack.config.js 或通过npx直接查找执行1npx webpack --config webpack.config.js 或者在package.json里面配置npx webpack –config webpack.config.js1npm run build 最后通过浏览器打开index.html文件就也可以看到index.js创建出来的div标签，可见webpack达到了和上面一样的效果，传统方式的不足也解决，当然webpack的优点不止于此，可通过后面的章节一起了解到更多。 github代码]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新概念英语第一册 05 Nice to meet you]]></title>
    <url>%2F2019%2F05%2F30%2Fenglish%2Fnewconceptenglish%2Flession05%2F</url>
    <content type="text"><![CDATA[Is Chang-Woo chinese? ContentGood morning. Good morning, Mr. blake. This is Miss Sophie Dupont. Sophie is an new student. She is French Nice to meet you. Sophie, this is Hans. He is German. Nice to meet you. And this is NaoKo. She is Japanese. Nice to meet you. And this is Chang-woo. He is Korean. Nice to meet you. This is Luming. Nice to meet you. He is Chinese. Nice to meet you. This is Xiaohui. She’s Chinese, too. Nice to meet you. VocabularyGerman Japanese Korean Italian Swedish American Explanation冠词冠词数量上标识一个或这个用来修饰名词 不定冠词a，an是不定冠词，可数名词前必须要用不定冠词，名词是辅音开头用a，名词是元音开头用an 定冠词 特指名词，表示说话或听话人已知的人或物时用the，There is an apple on the floor. The apple is mine. 专有的特属名词或独一无二的事物用the，The Great Wall, the sun 乐器用the，She paly the piano 表示人体部位用the，He pat me on the back 表示一家人用the，The Smith live in the apartment above ours]]></content>
      <categories>
        <category>english</category>
        <category>新概念英语第一册</category>
      </categories>
      <tags>
        <tag>新概念英语第一册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新概念英语第一册 03 Sorry, sir]]></title>
    <url>%2F2019%2F05%2F30%2Fenglish%2Fnewconceptenglish%2Flession03%2F</url>
    <content type="text"><![CDATA[Does the man get his umbrella back? ContentMy coat and my umbrella please. Here is my ticket. Thank you, sir. Number five. Here is your umbrella and caot. This isn’t my umbrella. Sorry sir. Is this your umbrella No, it isn’t. is this it? yes, it is. Thank you very much. Vocabularyumbrellla 雨伞 cloakroom 衣帽间；寄存处 Explanation祈使句Help your self 请自己动手 Keep off the grass 远离草地/请勿践踏草地 倒装句Here is my ticket 我的票在这里]]></content>
      <categories>
        <category>english</category>
        <category>新概念英语第一册</category>
      </categories>
      <tags>
        <tag>新概念英语第一册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新概念英语第一册 01 Excuse me]]></title>
    <url>%2F2019%2F05%2F30%2Fenglish%2Fnewconceptenglish%2Flession01%2F</url>
    <content type="text"><![CDATA[Whose handbag is it? ContentExcuse me ? Yes? is this your handbag? pardon ? is this your handbag? yes it is. thank you very much! Vocabularyticket Explanation陈述句This is your watch. 疑问句Is this your watch？]]></content>
      <categories>
        <category>english</category>
        <category>新概念英语第一册</category>
      </categories>
      <tags>
        <tag>新概念英语第一册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC对象内存结构]]></title>
    <url>%2F2019%2F05%2F29%2Fios%2F%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%2FOC%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[OC对象底层其实是由c/c++结构体，然后转成汇编最后到机器语言。 isa指针oc代码中的一个普通对象1NSObject *objc = [[NSObject alloc] init]; 我们在终端用clang编译成c/c++代码1clang -rewrite-objc main.m -o main.cpp 实际生成的c/c++代码个机构体，里面包含了一个isa指针123struct NSObject_IMPL &#123; Class isa;&#125;; Class其实又是objc_class结构体指针1typedef struct objc_class *Class; 那么一个指针的大小是多少呢，一般32位CPU是4字节，64位CPU是8字节。 一般我们所说的32或64位处理器，就是指该处理器的寻址位数，不同位数的CPU对于对应的是不同的内存寻址的能力，一个字节对应8位二进制，因此32位CPU=32/8,64位CPU=64/8 对象的内存大小我们先创建一个普通的Student对象123456@interface Student : NSObject&#123; @public int _no; int _age;&#125;@end 然后通过clang编译生成c++代码1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp 可以发现最终编译成的结构体如下12345struct Student_IMPL &#123; struct NSObject_IMPL NSObject_IVARS; // 8Byte int _no; // 4Byte int _age; // 4Byte&#125;; OC的Student对象编译成c++后，变成了Student_IMPL结构体，并包含一个NSObject_IMPL结构体及两个结构体成员，其中NSObject_IMPL是一个包含isa指针的结构体，我们统一以64位处理器为例，那么所占的内存空间就是8字节，另外两个成员分别是int占4字节。根据内存对齐原则，Student对象共占16字节大小。 对象的内存结构通过Xocde查看内存结构我们通过xocde打断点进一步查看Student对象的内存地址可以得到，在对象断点处右键Debug Workflow -&gt; viewMemory memory of “*stu”来查看内存地址123Student *stu = [[Student alloc] init]; // C9 13 00 00 01 80 1D 00 00 00 00 00 00 00 00 00stu-&gt;_no = 4; // C9 13 00 00 01 80 1D 00 04 00 00 00 00 00 00 00stu-&gt;_age = 5; // C9 13 00 00 01 80 1D 00 04 00 00 00 05 00 00 00 当stu对象刚创建出来时候，前8个字节C913000001801D00代表的是就是isa指针的地址，后8个字节的内存空间是预留出来了，都是0000000000000000，然后断点往下走，当给成员变量_no和_age赋值的时候变成了04000000 05000000 这里涉及到大小端排列模式的问题 大端模式是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。 小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低 由此可见ios是采用小端模式 通过LLDB指令查看并修改变量的值Xcode自带LLDB调试指令，下面我们通过LLDB调试指令来查看并动态修改某个属性内存的值12memory read/4xw# 0x100505410: 0x73c6ae80 0x00007fff 0x00000000 0x00000000 LLDB查看内存地址指令格式：memory read/数量 _ 格式 _ 字节数 内存地址，数量代表从内存地址起始位置开始打印多少，格式代表是以多少进制显示，字节数代表按照多少字节读取 目前属性还没有复制我们继续断点往下走，再执行一次以十进制的方式查看123456memory read/4dwmemory read/4dw # 0x1005053f0: 5065# 0x1005053f4: 1933313# 0x1005053f8: 4# 0x1005053fc: 5 接下来我们来动态修改下某个属性的值12345678memory write 0x1005053f8 2memory read/4dw stu# 0x1005053f0: 5065# 0x1005053f4: 1933313# 0x1005053f8: 2# 0x1005053fc: 5po stu-&gt;_no# 2 github代码]]></content>
      <categories>
        <category>ios</category>
        <category>底层源码</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git版本控制 (一)]]></title>
    <url>%2F2019%2F01%2F11%2Fbase%2Fgit%2Fgit%2F</url>
    <content type="text"><![CDATA[初始化仓库1$ git init 从现有仓库克隆123$ git clone git://github.com/schacon/xxxxx.git// 克隆的时候自定义文件夹$ git clone git://github.com/schacon/grit.git mygrit 检查当前文件状态1$ git status 跟踪新文件1$ git add git add 会递归所有文件，同时还可以把冲突文件标记为已解决 忽略某些文件gitignore规范 所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略 可以使用标准的 glob 模式匹配 匹配模式最后跟反斜杠（/）说明要忽略的是目录 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 For example12345678910111213# 此为注释 – 将被 Git 忽略# 忽略所有 .a 结尾的文件*.a# 但 lib.a 除外!lib.a# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO/TODO# 忽略 build/ 目录下的所有文件build/# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txtdoc/*.txt# 忽略 doc/ 目录下所有扩展名为 txt 的文件doc/**/*.txt 查看已暂存和未暂存的更新1git diff 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容 12git diff --cachedgit diff -- staged // 1.6.1 version lat 次命令是看已经暂存起来的文件和上次提交时的快照之间的差异 提交更新123git commit //会默用vim打开生成一个提交信息git commit -m &quot;test&quot; //快捷方式直接输入提交信息` 跳过使用暂存区域尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 git commit 加上 -a 选项1git commit -a -m &apos;test&apos; 此命令相当于执行了git add 再执行 git commit -m “test” 移除文件123rm test.html //移除文件git rm text.html //staged区移除git rm -f text.html //如果之前对删除文件有过修改并在staged中可能需要强制删除命令 另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆 .a 编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 .gitignore 文件中补上，用 –cached 选项即可1git rm --cached readme.txt 后面可以列出文件或者目录的名字，也可以使用 glob 模式。比方说：1git rm log/\*.log 注意到星号 * 之前的反斜杠 \，因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开（译注：实际上不加反斜杠也可以运行，只不过按照 shell 扩展的话，仅仅删除指定目录下的文件而不会递归匹配。上面的例子本来就指定了目录，所以效果等同，但下面的例子就会用递归方式匹配，所以必须加反斜杠。）。此命令删除所有 log/ 目录下扩展名为 .log 的文件。类似的比如：1git rm \*~ 会递归删除当前目录及其子目录中所有 ~ 结尾的文件 移动文件1git mv file_from file_to 运行 git mv 就相当于运行了下面三条命令123$ mv README.txt README$ git rm README.txt$ git add README 如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式都一样。当然，直接用 git mv 轻便得多，不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名 查看提交历史12345678910111213141516171819202122git log 所有提交git log -1 // 最近一次提交git log -p // 会展示每次提交的差异git log -p -2 最近两次提交并展示diffgit log -U1 --word-diff // 这里的对比显示在行间。新增加的单词被 &#123;+ +&#125; 括起来，被删除的单词被 [- -] 括起来git log --stat // 显示简要的增改行数统计git log --pretty=oneline //一行显示git log --pretty=short // 精简模式git log --pretty=format:&quot;%h - %an, %ar : %s&quot; // 格式化git log --pretty=format:&quot;%h %s&quot; --graph // 格式并图形化显示-p 按补丁格式显示每个更新之间的差异--word-diff 按 word diff 格式显示差异--stat 显示每次更新的文件修改统计信息。--shortstat 只显示 --stat 中最后的行数修改添加移除统计--name-only 仅在提交信息后显示已修改的文件清单。--name-status 显示新增、修改、删除的文件清单--abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。--relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。--graph 显示 ASCII 图形表示的分支合并历史--pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）--oneline --pretty=oneline --abbrev-commit 的简化用法 12345678910111213git log --since=2.weeks //近两周内的提交git log -Sfunction_name //找出添加或移除了某一个特定函数的引用的提交git log --pretty=&quot;%h - %s&quot; --author=gitster --since=&quot;2008-10-01&quot; --before=&quot;2008-11-01&quot; --no-merges -- t //2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件-(n) 仅显示最近的 n 条提交 --since, --after 仅显示指定时间之后的提交 --until, --before 仅显示指定时间之前的提交--author 仅显示指定作者相关的提交--committer 仅显示指定提交者相关的提交--grep 仅显示含指定关键字的提交-S 仅显示添加或移除了某个关键字的提交 撤消操作12345678910111213141516git commit --amend //修改上一条的提交信息$ git commit -m &apos;initial commit&apos;$ git add forgotten_file$ git commit --amend// 修改上一条并提交新的信息成一个提交git checkout . git checkout 文件名 //修改了文件没有add操作时用checkoutgit reset . git reset 文件名// 修改并add之后 需要用resetgit config --global core.quotepath false//git status中文文件名编码问题解决 远程仓库的使用1234567891011121314151617181920212223242526272829303132333435363738git remote //列出每个远程库的简短名字git remote --verbose // 更详细点会包含远程仓库地址git remote add [shortname] [url] // 添加一个新的远程仓库，可以指定一个简单的名字git fetch [shortname] // 抓取远程仓库的所有信息并下载数据到本地此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支有一点很重要，需要记住，fetch命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并git clone [url] 此命令本质上就是自动创建了本地的 master分支用于跟踪远程仓库中的 master分支（假设远程仓库确实有 master 分支）所以一般我们运行 git pull，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支//推送数据到远程仓库git push [remote-name] [branch-name]git push origin master//查看远程仓库信息git remote show [remote-name]git remote show origin//远程仓库的删除和重命名git remote rename [old-name] [new-name]git remote rename pb paul// 移除远程仓库git remote rmgit remote rm paul 打标签123456789101112131415161718192021222324252627282930313233343536373839404142//列显已有的标签git tag//用特定的搜索模式列出符合条件的标签git tag -l &apos;v1.4.2.*&apos;//新建含附注的标签git tag -a v1.4 -m &apos;my version 1.4&apos; //-a 代表 annotated -m 代表说明信息git show v.14 // 查看//签署标签git tag -s v1.5 -m &apos;my signed 1.5 tag&apos;git show v1.5 // 查看//轻量级标签git tag v1.6-lwgit show v1.6 // 查看的到的信息比较简单//验证标签git tag -v [tag-name]git tag -v v1.4.2.1（译注：取 verify 的首字母）的方式验证已经签署的标签。此命令会调用GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证//后期加注标签可以在后期对早先的某次提交加注标签只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可git tag -a v1.2 9fceb02//分享标签git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 git push origin [tagname] 即可git push origin [tagname]git push origin v1.5git push origin --tags // 一次推送所有本地新增的标签上去 技巧和窍门自动补全 如果你用的是 Bash shell，可以试试看 Git 提供的自动补全脚本。下载 Git 的源代码，进入 contrib/completion 目录，会看到一个 git-completion.bash 文件。将此文件复制到你自己的用户主目录中（译注：按照下面的示例，还应改名加上点：cp git-completion.bash ~/.git-completion.bash），并把下面一行内容添加到你的 .bashrc 文件中：1source ~/.git-completion.bash 也可以为系统上所有用户都设置默认使用此脚本。Mac 上将此脚本复制到 /opt/local/etc/bash_completion.d 目录中，Linux 上则复制到 /etc/bash_completion.d/ 目录中。这两处目录中的脚本，都会在 Bash 启动时自动加载。 如果在 Windows 上安装了 msysGit，默认使用的 Git Bash 就已经配好了这个自动补全脚本，可以直接使用。 在输入 Git 命令的时候可以敲两次跳格键（Tab），就会看到列出所有匹配的可用命令建议：12$ git co&lt;tab&gt;&lt;tab&gt;commit config Git 命令别名1234$ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status 可以看出，实际上 Git 只是简单地在命令中替换了你设置的别名。不过有时候我们希望运行某个外部命令，而非 Git 的子命令，这个好办，只需要在命令前加上 ! 就行。如果你自己写了些处理 Git 仓库信息的脚本的话，就可以用这种技术包装起来。作为演示，我们可以设置用 git visual 启动 gitk：1$ git config --global alias.visual &apos;!gitk&apos; git分支Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针 Git 是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为 HEAD 的特别指针，这个指针指向分支 冲突解决123456789修改完冲突文件后执行git add . //保存快照git commit // 完成合并提交git branch //所有分支的清单git branch -v //查看各个分支最后一个提交对象的信息git branch --merged //查看哪些分支已被并入当前分支git branch --no-merged //查看尚未合并的工作git branch -d [branch-name] //可以删除已合并的分支git branch -D [branch-name] //强制删除未合并的分支 远程分支一次 Git 克隆会建立你自己的本地分支 master 和远程分支 origin/master，并且将它们都指向 origin 上的 master 分支如果你在本地 master 分支做了些改动，与此同时，其他人向 git.ourcompany.com推送了他们的更新，那么服务器上的 master 分支就会向前推进，而与此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 origin/master 指针仍然保持原位不会移动 可以运行 git fetch origin 来同步远程服务器上的数据到本地。该命令首先找到 origin 是哪个服务器（本例为 git.ourcompany.com），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 origin/master 的指针移到它最新的位置上（见图 3-24） 现在你可以用 git fetch teamone 来获取小组服务器上你还没有的数据了 推送本地分支 可以运行 git push (远程仓库名) (分支名)123456789git push origin serverfixor git push origin serverfix:serverfixorgit push origin serverfix:awesomebranch//本地分支推送到某个命名不同的远程分支//这里其实走了一点捷径。Git 自动把 serverfix 分支名扩展为 refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”//当你的协作者再次从服务器上获取数据时执行git fetch origin 值得注意的是，在 fetch 操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支。换句话说，在本例中，你不会有一个新的 serverfix 分支，有的只是一个你无法移动的 origin/serverfix 指针 如果要把该远程分支的内容合并到当前分支，可以运行 git merge origin/serverfix。如果想要一份自己的 serverfix 来开发，可以在远程分支的基础上分化出一个新的分支来123456789$ git checkout -b serverfix origin/serverfixor$ git checkout serverfix如果你有 1.6.2 以上版本的 Git，还可以用 --track 选项简化$ git checkout --track origin/serverfix要为本地分支设定不同于远程分支的名字，只需在第一个版本的命令里换个名字git checkout -b sf origin/serverfix 删除远程分支 记住我们不久前见过的 git push [远程名] [本地分支]:[远程分支] 语法12$ git push origin :serverfix//那就等于是在说“在这里提取空白然后把它变成[远程分支]”]]></content>
      <categories>
        <category>基础</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式 (一)]]></title>
    <url>%2F2019%2F01%2F11%2Fbase%2Fregular%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简单文本检索123/123/.test(1234) true/123/.test(0123) true/123/.test(01223) false 上述正则表示存在匹配的匹配的连续字母或数字 起始和结束位置检索123/^cat/.test(&quot;cateee&quot;) //true/^cat/.test(&quot;acateee&quot;) //flase/cat$/.test(&quot;acat&quot;) //true 上述正则表示存在匹配的匹配的连续字母或数字并以其开头或以其结尾 匹配若干字符12/gr[ae]y/.test(&quot;grey&quot;) //true/gr[ae]y/.test(&quot;gray&quot;) //true []内表示字母或数字中其中一个就满足，类似或的意思12345/H[1-9]/.test(&quot;H1&quot;) //true/H[1-9]/.test(&quot;H2&quot;) //true/H[1-9]/.test(&quot;H0&quot;) //false/H[a-z]/.test(&quot;Hb&quot;) //true/H[a-z]/.test(&quot;H1&quot;) //false [-]连字符表示一个范围满足即可123/[0-9a-fA-F]/.test(&quot;A&quot;) //true/[0-9a-fA-F]/.test(&quot;.&quot;) //false/[0-9a-fA-F_.?!]/.test(&quot;?&quot;) //true 上述表达式是连字符和各种字符的组合 注意:只有在字符组内部且非开头位置连字符才是元字符，否则就是匹配普通字符 排除型字符组12/[^1-6]/.test(9) //true /[^1-6]/.test(5) //false ^一般情况下是代表起始位置，但是在字符组内部且紧接在字符组第一个方括号后，就代表一个排除型的元字符 匹配任意字符123/2018.12.12/.test(&quot;2018-12-12&quot;) //true/2018.12.12/.test(&quot;2018:12:12&quot;) //true/2018.12.12/.test(&quot;2018@12@12&quot;) //true .代表可以匹配任意字符 表达式组合12345678/Bob|Robert/.test(&quot;Bob&quot;) //true/Bob|Robert/.test(&quot;Robert&quot;) //true/gray|grey/.test(&quot;gray&quot;) //true/gray|grey/.test(&quot;grey&quot;) //true/gr(a|e)y/.test(&quot;gray&quot;) //true/gr(a|e)y/.test(&quot;grey&quot;) //true/gr(aa|ee)y/.test(&quot;greey&quot;) //true/gr(aa|ee)y/.test(&quot;graay&quot;) //true |代表语句的或，多选语句可以包括多个字符但是需要再括号内否则意思就不一样例如下面的 12345678/^From|Subject|Date:*/.test(&quot;From&quot;) //true/^From|Subject|Date:*/.test(&quot;Subject&quot;) //true/^From|Subject|Date:*/.test(&quot;HSubject&quot;) //true/^(From|Subject|Date):*/.test(&quot;From&quot;) //false/^(From|Subject|Date):*/.test(&quot;Subject&quot;) //false/^(From|Subject|Date):*/.test(&quot;HSubject&quot;) //false/^(From|Subject|Date):*/.test(&quot;Subject:hello&quot;) //ture 注意：一个字符组可以匹配目标文本的单个字符，而多选结构可能是完整语句，可以匹配任意长度文本 忽略大小写12345/[Ff][Rr][Oo][Mm]/.test(&quot;from&quot;) //true/[Ff][Rr][Oo][Mm]/.test(&quot;From&quot;) //true/from/i.test(&quot;FROM&quot;) //true i不是正则表达式的一部分，是工具或者编程语言提供的相关性，表示忽略大小写。 可选量词1234567/colou?r/.test(&quot;color&quot;) //true/colou?r/.test(&quot;colour&quot;) //true/colou?r/.test(&quot;coloor&quot;) //false/col(ou)?r/.test(&quot;colr&quot;) //true/col(ou)?r/.test(&quot;colour&quot;) //true/col(ou)?r/.test(&quot;color&quot;) //false 表示容许出现？对应紧挨的字符（非其他字符），或者没有这个字符。 重复量词12345/ *hello +world */.test(&quot;hello world&quot;) //true/ *hello +world */.test(&quot; hello world &quot;) //true/ *hello +world */.test(&quot;helloworld&quot;) //false/ *hello +world +[0-9]+/.test(&quot;hello world 123&quot;) //true/ *hello +world +[0-9]+/.test(&quot;hello world&quot;) //false *代表紧挨的字符出现任意次数包含0次，也就是出现多次或者不出现都可以，？代表出现一次或不出现。+代表最少出现一次，如果没出现就不匹配报错。 重复期间12/[a-z][0-9]&#123;5,9&#125;/.test(&quot;a12345&quot;) //true/[a-z][0-9]&#123;5,9&#125;/.test(&quot;a1234&quot;) //false {,}代表重复次数的区间，其实？就是{0,1}重复区间 括号及反向查询当匹配中的分组有嵌套时，是从外向里匹配的，其次在由左向右匹配12345/^([0-9])\1[0-9]([0-9])\1&#123;2&#125;/.test(335933) //true/^([0-9])\1[0-9]([0-9])\1&#123;2&#125;/.test(335944) //false/^([0-9])\1[0-9]([0-9])\2&#123;2&#125;/.test(335777) //true/^(([a-z])3)\1k([A-Z])\2&#123;2&#125;/.test(&quot;a3a3kAaa&quot;) //true/^([a-z]3)\1k([A-Z])\2&#123;2&#125;/.test(&quot;a3a3kAAA&quot;) //true 转义符号123/.[a-z]/.test(&quot;1a&quot;) //true/\.[a-z]/.test(&quot;1a&quot;) //false/\.[a-z]/.test(&quot;.a&quot;) //true 正则表达式中很多元字符如.?*等,直接使用就是有语意的元字符，比如.代表任何匹配的字符，但是如果我只想匹匹配.或者？好怎么办，那么就需要加个\转义字符，让元字符失去特殊字符含义，只表示这是一个a-z字母数字一样的普通字符匹配，如果\后面跟的不是元字符需要根据具体版本而定，另外字符组内部的反斜杠也需要根据不同版本而定]]></content>
      <categories>
        <category>基础</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
</search>
