<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue的计算属性]]></title>
    <url>%2F2019%2F08%2F28%2Fvue%2Fvue%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[模板表达式之前学了模板表达式子，简单回顾下写法12345678910 &lt;div id="app"&gt; &#123;&#123;message.split('').reverse().join('')&#125;&#125;&lt;/div&gt;var app = new Vue(&#123; el: '#app', data:&#123; message:"HelloComputedProperties" &#125;&#125;) 函数表达式我们之前了解到模板表达式只能写简单的单行表达式，复杂的多行都不支持，这时候我们可以在表达式内调用方法 12345678910111213141516171819202122232425 &lt;div id="app2"&gt; &#123;&#123;reverseMessage()&#125;&#125; &#123;&#123;dataFormat()&#125;&#125;&lt;/div&gt;var app2 = new Vue(&#123; el: '#app2', data:&#123; message:'HelloComputedProperties', &#125;, methods:&#123; reverseMessage:function()&#123; var date = new Date() return this.message.split('').reverse().join('') + date; &#125;, dataFormat: function()&#123; // alert('execute method') return new Date() &#125; &#125;&#125;)setTimeout(() =&gt; &#123; app2.message = 'hello'&#125;, 2000); 看上去使用函数表达式可以解决负责的属性修改运算，但是仔细发现看视图显示的或者打开注释的alert方法，我们发在修改message的时候，不仅调用了reverseMessage的方法，同时还调用了dataFormat方法，这也许不是我们希望的结果，那么这时候就需要用到计算属性 计算属性123456789101112131415161718192021222324&lt;div id="app3"&gt; &#123;&#123;reverseMessage&#125;&#125; &#123;&#123;dataFormat&#125;&#125;&lt;/div&gt;var app3 = new Vue(&#123; el: '#app3', data:&#123; message:'HelloComputedProperties', &#125;, computed:&#123; reverseMessage:function()&#123; return this.message.split('').reverse().join(''); &#125;, dataFormat: function()&#123; // alert('execute cuompute method') return new Date() &#125; &#125;&#125;)setTimeout(() =&gt; &#123; app3.message = 'hello'&#125;, 2000); 这时候我们发现修改message只会熏染与message相关的计算属性方法，而不会引起dataFormate方法调用及渲染。 github代码]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的模板语法]]></title>
    <url>%2F2019%2F08%2F27%2Fvue%2Fvue%E7%9A%84%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[vue和react小程序的模板语法基本都差不多，下面来简单写几个模板语法的demo 数据绑定通过声明data每次修改data里面的值，视图层都会跟着渲染。12345678910&lt;div id="app"&gt; &lt;span&gt;message: &#123;&#123;message&#125;&#125;&lt;/span&gt;&lt;/div&gt;var app = new Vue(&#123; el: '#app', data:&#123; message: 'hello' &#125;&#125;) 通过声明添加v-once后，视图只会渲染一次，以后data变化都不会改变视图1234567891011121314&lt;div id="app2"&gt; &lt;span v-once&gt;message: &#123;&#123;message&#125;&#125;&lt;/span&gt;&lt;/div&gt;var app2 = new Vue(&#123; el: '#app2', data:&#123; message: '' &#125;&#125;)setTimeout(() =&gt; &#123; app2.message = 'hi' // 这时候修改视图层不会响应&#125;, 1000); 有时候需要直接渲染html标签，那么可以使用v-html，但是使用需谨慎，渲染不安全的html字符串容易导致XSS攻击。12345678910&lt;div id="app3"&gt; &lt;span v-html="headHtml"&gt;&lt;/span&gt;&lt;/div&gt;var app3 = new Vue(&#123; el: '#app3', data:&#123; headHtml:'&lt;h1&gt;h1 title&lt;/h1&gt;' &#125;&#125;) 有时候我们需要对html标签的某些属性进行直接绑定，这时候可以使用v-bind指令1234567891011121314&lt;div id="app4"&gt; &lt;span v-bind:id="dynamicId"&gt;dynamic id&lt;/span&gt; &lt;span v-bind:style="dynamicStyle"&gt;dynamic style&lt;/span&gt; &lt;button v-bind:disabled="btnDisable"&gt;disable button&lt;/button&gt;&lt;/div&gt;var app4 = new Vue(&#123; el: '#app4', data:&#123; dynamicId:1, dynamicStyle:'background-color: green', btnDisable: true &#125;&#125;) 表达式使用双括号可以使用javascript的表达式，但是只能用单个表达式。12345678910111213&lt;div id="app5"&gt; &#123;&#123;number + 1&#125;&#125; &#123;&#123;number == 1 ? 'true' : 'false'&#125;&#125; &#123;&#123;message.slice(5)&#125;&#125;&lt;/div&gt;var app5 = new Vue(&#123; el: '#app5', data:&#123; number:1, message: 'hellovue' &#125;&#125;) 指令使用v-on指令可以为标签添加点击方法123456789101112&lt;div id="app6"&gt; &lt;div v-on:click="onClick" style="background-color: yellow; display: inline-block"&gt;click me&lt;/div&gt;&lt;/div&gt;var app6 = new Vue(&#123; el: "#app6", methods:&#123; onClick:function()&#123; alert('click event'); &#125; &#125;&#125;) 使用v-bind:[]指令可以动态的修改绑定的属性名1234567891011&lt;div id="app7"&gt; // 注意这里attributeName会被转成小写attributename &lt;input type="text" v-bind:[attributeName]="123" /&gt;&lt;/div&gt;var app7 = new Vue(&#123; el: "#app7", data:&#123; attributename:'value' &#125;&#125;) 指令还可以加修饰符，比如添加一个.prevent修饰符可以阻止原来标签的动作12345678910111213141516&lt;div id="app8"&gt; &lt;a href="http:www.baidu.com" v-on:click="click1" &gt;universally click &lt;/a&gt; &lt;a href="http:www.baidu.com" v-on:click.prevent="click2" &gt; prevent click &lt;/a&gt;&lt;/div&gt;var app8 = new Vue(&#123; el: "#app8", methods:&#123; click1:function()&#123; alert("jump to website"); &#125;, click2:function()&#123; alert("use prevent don't jump to website"); &#125; &#125;&#125;) 为了简洁方便指令还可以使用@和:的简写方式来表示12345678910111213141516&lt;div id="app9"&gt; &lt;div @click="onClick" style="background-color: yellow; display: inline-block"&gt;shorthand of v-on&lt;/div&gt; &lt;input type="text" :value="message" /&gt;&lt;/div&gt;var app9 = new Vue(&#123; el: "#app9", data:&#123; message:'shorthand of v-bind:' &#125;, methods:&#123; onClick:function()&#123; alert("shorthand"); &#125; &#125;&#125;) github代码]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的入门]]></title>
    <url>%2F2019%2F08%2F27%2Fvue%2Fvue%E7%9A%84%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[按照官网文档写了一点简单入门实例，以下为了方便我们直接使用script引入Vue123&lt;head&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt; &lt;/head&gt; 声明渲染1234567891011&lt;div id="app"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125; &#125;) &lt;/script&gt; 属性绑定123456789101112 &lt;div id="app2"&gt; &lt;span v-bind:title="message"&gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &lt;/span&gt; &lt;/div&gt; var app2 = new Vue(&#123; el: '#app2', data: &#123; message: 'Hello Vue 2' &#125;&#125;) 条件语句1234567891011121314&lt;div id="app3"&gt; &lt;p v-if="show"&gt;显示&lt;/p&gt;&lt;/div&gt; var app3 = new Vue(&#123; el: '#app3', data: &#123; show: false &#125; &#125;)setTimeout(() =&gt; &#123; app3.show = true&#125;, 1000); 循环语句1234567891011121314&lt;div id="app4"&gt; &lt;ol&gt; &lt;li v-for="item in list"&gt; &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; var app4 = new Vue(&#123; el: '#app4', data: &#123; list: ["javascript","css","html","vue"] &#125; &#125;) 点击事件1234567891011121314151617181920&lt;div id="app5"&gt; &lt;p&gt;&#123;&#123;number&#125;&#125;&lt;/p&gt; &lt;button v-on:click="increase"&gt;点击增加&lt;/button&gt; &lt;button v-on:click="reduce"&gt;点击减少&lt;/button&gt;&lt;/div&gt;var app5 = new Vue(&#123; el:'#app5', data:&#123; number:1 &#125;, methods:&#123; increase: function()&#123; this.number += 1; &#125;, reduce: function()&#123; this.number -= 1; &#125; &#125; &#125;) 双向绑定1234567891011121314&lt;div id="app6"&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;input type="text" v-model="message"&gt;&lt;/div&gt; var app6 = new Vue(&#123; el: '#app6', data: &#123; message: 'Hello Vue!' &#125; &#125;)setTimeout(() =&gt; &#123; app6.message = "Changed"&#125;, 2000); 自定义组件123456789101112131415161718192021&lt;div id="app7"&gt; &lt;ol&gt; &lt;custom-item v-for="item in wareList" v-bind:data="item" v-bind:key="item.id"&gt; &lt;/custom-item&gt; &lt;/ol&gt;&lt;/div&gt;Vue.component('custom-item',&#123; props:['data'], template: '&lt;li&gt;&#123;&#123;data.text&#125;&#125;&lt;/li&gt;' &#125;) var app7 = new Vue(&#123; el:'#app7', data:&#123; wareList:[ &#123;id:0,text:'vegetable'&#125;, &#123;id:1,text:'biscuit'&#125; ] &#125; &#125;) 以上是简单的入门示例，感觉和React及小程序的写法大同小异。 github代码]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native的拆分包基于diff-match-patch]]></title>
    <url>%2F2019%2F08%2F12%2Frn%2Freact-native%E7%9A%84%E6%8B%86%E5%88%86%E5%8C%85%E5%9F%BA%E4%BA%8Ediff-match-patch%2F</url>
    <content type="text"><![CDATA[纯RN项目在实际开发过程中很少见，大多数原有项目嵌套RN，经常针对是某个页面或模块用一个RN包，这时候就存在多个RN包问题，每个RN包中都包含了一些基础的common代码，这部分代码体积大约有700KB左右，随着包的个数增加，重复的common代码将会越来越多，这样当时是我们不想看到的结果，这时候就需要用到拆分包的方案。 目前主流的拆分包方案大致有3种 基于google-diff-match-patch来实现，打一个空View的包生成common包，再打一个包含业务代码的包生成全量包，然后对比全量包和common生成diff包即业务包。 打一个空View包，并在View中添加一个监听方法，用打包工具生成business包及对应id，原生代码加载完成business后，发送消息给空View，空View加载渲染business。 基于metro直接打包生成common和business包。 这里我们先演示下google-diff-match-patch的diff拆分包方案 首先我们新建一个iOS项目，并生成配置下pod1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Uncomment the next line to define a global platform for your projectplatform :ios, &apos;9.0&apos;require_relative &apos;../node_modules/@react-native-community/cli-platform-ios/native_modules&apos;target &apos;RNSplitePack&apos; do # Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks # use_frameworks! # Pods for RNSplitePack pod &apos;React&apos;, :path =&gt; &apos;../node_modules/react-native/&apos; pod &apos;React-Core&apos;, :path =&gt; &apos;../node_modules/react-native/React&apos; pod &apos;React-DevSupport&apos;, :path =&gt; &apos;../node_modules/react-native/React&apos; pod &apos;React-fishhook&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/fishhook&apos; pod &apos;React-RCTActionSheet&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/ActionSheetIOS&apos; pod &apos;React-RCTAnimation&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/NativeAnimation&apos; pod &apos;React-RCTBlob&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/Blob&apos; pod &apos;React-RCTImage&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/Image&apos; pod &apos;React-RCTLinking&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/LinkingIOS&apos; pod &apos;React-RCTNetwork&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/Network&apos; pod &apos;React-RCTSettings&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/Settings&apos; pod &apos;React-RCTText&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/Text&apos; pod &apos;React-RCTVibration&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/Vibration&apos; pod &apos;React-RCTWebSocket&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/WebSocket&apos; pod &apos;React-cxxreact&apos;, :path =&gt; &apos;../node_modules/react-native/ReactCommon/cxxreact&apos; pod &apos;React-jsi&apos;, :path =&gt; &apos;../node_modules/react-native/ReactCommon/jsi&apos; pod &apos;React-jsiexecutor&apos;, :path =&gt; &apos;../node_modules/react-native/ReactCommon/jsiexecutor&apos; pod &apos;React-jsinspector&apos;, :path =&gt; &apos;../node_modules/react-native/ReactCommon/jsinspector&apos; pod &apos;yoga&apos;, :path =&gt; &apos;../node_modules/react-native/ReactCommon/yoga&apos; pod &apos;DoubleConversion&apos;, :podspec =&gt; &apos;../node_modules/react-native/third-party-podspecs/DoubleConversion.podspec&apos; pod &apos;glog&apos;, :podspec =&gt; &apos;../node_modules/react-native/third-party-podspecs/glog.podspec&apos; pod &apos;Folly&apos;, :podspec =&gt; &apos;../node_modules/react-native/third-party-podspecs/Folly.podspec&apos; pod &apos;Folly&apos;, :podspec =&gt; &apos;../node_modules/react-native/third-party-podspecs/Folly.podspec&apos; target &apos;RNSplitePackTests&apos; do inherit! :search_paths # Pods for testing end target &apos;RNSplitePackUITests&apos; do inherit! :search_paths # Pods for testing endend 然后我们在项目跟目录创建一个package.json文件并install下react的库及diff-match-patch的库1234567891011121314151617181920&#123; "name": "RNSplitePack", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "start": "yarn react-native start", "test": "node ./script/diff.js" &#125;, "keywords": [], "author": "", "license": "ISC", "dependencies": &#123; "react": "^16.8.6", "react-native": "^0.60.4" &#125;, "devDependencies": &#123; "diff-match-patch": "^1.0.4" &#125;&#125; 接着我们在iOS工程中pod install下安装下相关依赖，之后我们将googel-diff-match-patch导入到工程，由于库比较老不支持pod同时有些MRC的文件需要配置下-fno-objc-arc。 这是我们整个简单的配置就基本完成，接下来我们就是进行common和business包拆分的流程。 我们分别创建一个common.js和business.js，common是一个空的view用于加载基础框架代码，business用于写业务的代码，随后我们使用react-native自带的带包工具分别打包两个文件12react-native bundle --platform ios --entry-file index.js --bundle-output ./dist/index.bundle --dev falsereact-native bundle --platform ios --entry-file common.js --bundle-output ./dist/common.bundle --dev false 另外我们再创建一个简单脚本文件diff.js用于生产diff文件。12345678910111213141516171819202122232425262728var DiffMatchPatch=require('diff-match-patch');var fs = require('fs'),path = require('path');var data1 = fs.readFileSync(path.resolve(__dirname, '../dist/common.bundle'), 'utf8');var data2 = fs.readFileSync(path.resolve(__dirname, '../dist/index.bundle'), 'utf8');var ms_start = (new Date).getTime();var dmp = new DiffMatchPatch();var diff = dmp.diff_main(data1, data2,true);if (diff.length &gt; 2) &#123; dmp.diff_cleanupSemantic(diff);&#125;var patch_list = dmp.patch_make(data1, data2, diff);var patch_text = dmp.patch_toText(patch_list);var ms_end = (new Date).getTime();fs.writeFile(path.resolve(__dirname, '../dist/business.patch'),patch_text,function(err)&#123; if(err)&#123; console.log(err); &#125;else&#123; var time = (ms_end - ms_start) / 1000 + 's'; console.log("生成patch包成功\n") console.log("耗时:"+ time); &#125;&#125;) 这时候我们执行下diff的脚本，就生产business.path包,这是我们再dist文件夹看到三个文件，其中common.bundle是放在客户端本地的基础包，diff就是业务包或叫补丁包，我们将这两个包导入到iOS工程中，用于react-native进行本地加载。 我们看下iOS工程中的测试加载的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)viewDidLoad &#123; [super viewDidLoad]; RCTBridge *bridge = [[RCTBridge alloc]initWithDelegate:self launchOptions:nil]; RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:bridge moduleName:@&quot;RNHighScores&quot; initialProperties:nil]; self.view = rootView;&#125;- (NSString *)getMergeBundlePath&#123; NSString *commonBundlePath = [[NSBundle mainBundle] pathForResource:@&quot;common&quot; ofType:@&quot;bundle&quot;]; NSLog(@&quot;path=%@&quot;,commonBundlePath); NSString *commonJsCode = [[NSString alloc] initWithContentsOfFile:commonBundlePath encoding:NSUTF8StringEncoding error:nil]; NSString *businessBundlePath = [[NSBundle mainBundle] pathForResource:@&quot;business&quot; ofType:@&quot;patch&quot;]; NSLog(@&quot;path=%@&quot;,businessBundlePath); NSString *businessJsCode = [[NSString alloc] initWithContentsOfFile:businessBundlePath encoding:NSUTF8StringEncoding error:nil]; DiffMatchPatch *diffMatchPatch = [[DiffMatchPatch alloc] init]; NSArray *convertedPatches = [diffMatchPatch patch_fromText:businessJsCode error:nil]; NSArray *resultsArray = [diffMatchPatch patch_apply:convertedPatches toString:commonJsCode]; NSString *resultJSCode = resultsArray[0]; //patch合并后的js NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *docDir = [paths objectAtIndex:0]; NSString *newPath = [NSString stringWithFormat:@&quot;%@/%@.bundle&quot;,docDir,@&quot;newbusiness&quot;]; if (resultsArray.count &gt; 1) &#123; BOOL ret = [resultJSCode writeToFile:newPath atomically:NO encoding:NSUTF8StringEncoding error:nil]; NSLog(@&quot;存入状态%d&quot;,ret); &#125; return newPath;&#125;- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge&#123; if (DEBUG) &#123; return [NSURL URLWithString:@&quot;http://localhost:8081/index.bundle?platform=ios&quot;]; &#125; else &#123; NSString *path = [self getMergeBundlePath]; NSURL *jsBundleURL = [NSURL URLWithString:path]; return jsBundleURL; &#125;&#125; 这里我们可以看到common和business在打包的时候进行拆分，在客户端本地加载的时候有进行了合并，基础代码合业务代码有效的进行了拆分，不论有多少个业务模块common代码只有一份，不会造成多余的重复代码浪费存储和下载空间，同时diff方案目前也是很多热修复补丁使用的方案，但是此方法也是存在某些不足的，比如说在客户端进行合并及存储操作中也是存在I/O耗时操作的。 github代码]]></content>
      <categories>
        <category>react native</category>
      </categories>
      <tags>
        <tag>react native 拆分包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类的本质]]></title>
    <url>%2F2019%2F08%2F03%2Fios%2F%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%2F%E5%88%86%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[开发过程中，我们经常用分类来添加一些通用方法，或者划分类的不同行为，那么分类在ios的底层的怎么设计的呢，我们先看看分类的结构体 分类的结构体我们首先创建一个Person类123@interface Person : NSObject@end 再创建一个Person的分类12345@interface Person (Test)- (void)say;@end 再通过xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc Preson+Test.m 生成cpp文件编译成c++文件 123456789101112131415161718struct _category_t &#123; const char *name; struct _class_t *cls; const struct _method_list_t *instance_methods; const struct _method_list_t *class_methods; const struct _protocol_list_t *protocols; const struct _prop_list_t *properties; &#125;; static struct _method_list_t &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[1]; &#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Test __attribute__ ((used, section ("__DATA,__objc_const"))) = &#123; sizeof(_objc_method), 1, &#123;&#123;(struct objc_selector *)"say", "v16@0:8", (void *)_I_Person_Test_say&#125;&#125; // 我们定义的say方法 &#125;; 通过分类结构体的instance_methods,class_methods,class_methods,properties,我们可以大致知道分类是用于存储对象方法，类方法，协议方法，属性等数据，那这些方法属性是如果关联到相关的类里面去的呢，我们接下来看看加载的流程 分类的加载过程我们知道分类的是运行时加载的，我们可以通过rumtime的源码去寻找分类的加载流程 objc-os.mm文件中有个_objc_init方法12345678910111213141516 void _objc_init(void)&#123;static bool initialized = false;if (initialized) return;initialized = true;// fixme defer initialization until an objc-using image is found?environ_init();tls_init();static_init();lock_init();exception_init();_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);&#125; 接着我们来到 &amp;map_images读取模块（images这里代表模块），来到map_images_nolock函数中找到_read_images函数，在_read_images函数中我们找到分类相关代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Discover categories. for (EACH_HEADER) &#123; category_t **catlist = _getObjc2CategoryList(hi, &amp;count); bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties(); for (i = 0; i &lt; count; i++) &#123; category_t *cat = catlist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) &#123; // Category's target class is missing (probably weak-linked). // Disavow any knowledge of this category. catlist[i] = nil; if (PrintConnecting) &#123; _objc_inform("CLASS: IGNORING category \?\?\?(%s) %p with " "missing weak-linked target class", cat-&gt;name, cat); &#125; continue; &#125; // Process this category. // First, register the category with its target class. // Then, rebuild the class's method lists (etc) if // the class is realized. bool classExists = NO; if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) &#123; addUnattachedCategoryForClass(cat, cls, hi); if (cls-&gt;isRealized()) &#123; remethodizeClass(cls); classExists = YES; &#125; if (PrintConnecting) &#123; _objc_inform("CLASS: found category -%s(%s) %s", cls-&gt;nameForLogging(), cat-&gt;name, classExists ? "on existing class" : ""); &#125; &#125; if (cat-&gt;classMethods || cat-&gt;protocols || (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) &#123; addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi); if (cls-&gt;ISA()-&gt;isRealized()) &#123; remethodizeClass(cls-&gt;ISA()); &#125; if (PrintConnecting) &#123; _objc_inform("CLASS: found category +%s(%s)", cls-&gt;nameForLogging(), cat-&gt;name); &#125; &#125; &#125; &#125; _getObjc2CategoryList函数获取到分类列表之后，进行遍历，获取其中的方法，协议，属性等。可以看到最终都调用了remethodizeClass(cls);函数。我们来到remethodizeClass(cls);函数内部查看。12345678910111213141516171819static void remethodizeClass(Class cls) &#123; category_list *cats; bool isMeta; runtimeLock.assertLocked(); isMeta = cls-&gt;isMetaClass(); // Re-methodizing: check for more categories if ((cats = unattachedCategoriesForClass(cls, false))) &#123; if (PrintConnecting) &#123; _objc_inform("CLASS: attaching categories to class '%s' %s", cls-&gt;nameForLogging(), isMeta ? "(meta)" : ""); &#125; attachCategories(cls, cats, true ); free(cats); &#125; 通过上述代码我们发现attachCategories函数接收了类对象cls和分类数组cats，如我们一开始写的代码所示，一个类可以有多个分类。之前我们说到分类信息存储在category_t结构体中，那么多个分类则保存在category_list中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586static void attachCategories(Class cls, category_list *cats, bool flush_caches) &#123; if (!cats) return; if (PrintReplacedMethods) printReplacements(cls, cats); bool isMeta = cls-&gt;isMetaClass(); // fixme rearrange to remove these intermediate allocations method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists)); property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists)); protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists)); // Count backwards through cats to get newest categories first int mcount = 0; int propcount = 0; int protocount = 0; int i = cats-&gt;count; bool fromBundle = NO; while (i--) &#123; auto&amp; entry = cats-&gt;list[i]; method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) &#123; mlists[mcount++] = mlist; fromBundle |= entry.hi-&gt;isBundle(); &#125; property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta, entry.hi); if (proplist) &#123; proplists[propcount++] = proplist; &#125; protocol_list_t *protolist = entry.cat-&gt;protocols; if (protolist) &#123; protolists[protocount++] = protolist; &#125; &#125; auto rw = cls-&gt;data(); prepareMethodLists(cls, mlists, mcount, NO, fromBundle); rw-&gt;methods.attachLists(mlists, mcount); free(mlists); if (flush_caches &amp;&amp; mcount &gt; 0) flushCaches(cls); rw-&gt;properties.attachLists(proplists, propcount); free(proplists); rw-&gt;protocols.attachLists(protolists, protocount); free(protolists); &#125;void attachLists(List* const * addedLists, uint32_t addedCount) &#123; if (addedCount == 0) return; if (hasArray()) &#123; // many lists -&gt; many lists uint32_t oldCount = array()-&gt;count; uint32_t newCount = oldCount + addedCount; setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); array()-&gt;count = newCount; memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0])); memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; else if (!list &amp;&amp; addedCount == 1) &#123; // 0 lists -&gt; 1 list list = addedLists[0]; &#125; else &#123; // 1 list -&gt; many lists List* oldList = list; uint32_t oldCount = oldList ? 1 : 0; uint32_t newCount = oldCount + addedCount; setArray((array_t *)malloc(array_t::byteSize(newCount))); array()-&gt;count = newCount; if (oldList) array()-&gt;lists[addedCount] = oldList; memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; &#125; 通过attachLists方法中的memmove方法之后，我们发现，虽然本类的方法，属性，协议列表会分别后移，但是本类的对应数组的指针依然指向原始位置。我们发现原来指针并没有改变，至始至终指向开头的位置。并且经过memmove和memcpy方法之后，分类的方法，属性，协议列表被放在了类对象中原本存储的方法，属性，协议列表前面。这样就实现了分类方法优先调用，可见分类的本质是优先调用并不是覆盖本类的方法。 github代码]]></content>
      <categories>
        <category>ios</category>
        <category>底层源码</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列的存储结构]]></title>
    <url>%2F2019%2F07%2F24%2Falgorithm%2F%E9%98%9F%E5%88%97%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[栈是先进后出，队列和栈相反，先进先出(First In First Out),简称FIFO。队列作为一种特殊的线性表，只允许队尾插入，队头删除，同样队列的也有多种存储方式，我们看下常见的几种。 队列的顺序存储队列的的顺序存储和线性表的顺序存储类似，只是添加删除的分别只能在对头和队尾 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX 10struct QueueList &#123; int data[MAX]; int head;&#125;;void printList(struct QueueList *list)&#123; int temp = list-&gt;head-1; while(temp &gt;= 0)&#123; printf("index:%d,value:%d\n",temp,list-&gt;data[temp]); temp --; &#125;&#125;void insertElement(struct QueueList *list,int element)&#123; list-&gt;data[list-&gt;head] = element; list-&gt;head++;&#125;void deleteElement(struct QueueList *list)&#123; if (list-&gt;head &gt; 0) &#123; int temp = 0; while(temp &lt; list-&gt;head)&#123; int next = temp + 1; list-&gt;data[temp] = list-&gt;data[next]; temp ++; &#125; list-&gt;head --; &#125;&#125;int main()&#123; struct QueueList list; list.head = 0; insertElement(&amp;list,0); insertElement(&amp;list,1); insertElement(&amp;list,2); insertElement(&amp;list,3); insertElement(&amp;list,4); printList(&amp;list); printf("删除后\n"); deleteElement(&amp;list); deleteElement(&amp;list); printList(&amp;list); return 0;&#125; 队列的顺序存储插入是比较方便的，时间复杂度是O(1),但是删除操作比较麻烦，每次都是删除对头元素后，后面的元素需要全部往前移动，时间复杂度是O(n),接下来看下来下面的顺序循环存储方式。 队列的顺序循环存储普通的顺序存储因为对头是固定在0的位置，因此删除的时候都需要一一移动后面的元素，为此我们可以不固定队头的位置为零，如果删除了队头一个元素，那么堆头的位置从堆头元素的下一个元素开始，这样后面的元素就不需要一一移动，然后这有引入另一个问题，之前的存储空间就浪费了。那这应该怎么处理呢，顺序循环存储方式就是因此而来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX 5typedef struct QueueList&#123; int data[MAX]; int head; int tail;&#125;List;void printList(List *list)&#123; if (list-&gt;head == list-&gt;tail) &#123; printf("空队列"); &#125; else &#123; int index = list-&gt;head; while(index != list-&gt;tail)&#123; printf("index:%d value:%d \n",index,list-&gt;data[index]); index = (index+1)%MAX; &#125; &#125;&#125;void insertList(List *list,int value)&#123; if ((list-&gt;tail+1)%MAX == list-&gt;head)&#123; printf("队列已满\n"); &#125; else &#123; list-&gt;data[list-&gt;tail] = value; list-&gt;tail = (list-&gt;tail + 1)%MAX; &#125;&#125;void removeElement(List *list)&#123; if (list-&gt;head == list-&gt;tail)&#123; printf("队列是空\n"); &#125; else &#123; list-&gt;head = (list-&gt;head+1)%MAX; &#125;&#125;int main()&#123; List list; list.head = 0; list.tail = 0; insertList(&amp;list,0); insertList(&amp;list,1); insertList(&amp;list,2); insertList(&amp;list,3); printf("删除之前\n"); printList(&amp;list); printf("删除之后\n"); removeElement(&amp;list); removeElement(&amp;list); removeElement(&amp;list); printList(&amp;list); printf("插入之后\n"); insertList(&amp;list,4); insertList(&amp;list,5); insertList(&amp;list,6); printList(&amp;list); return 0;&#125; 以上代码中我们需要着重理解下if ((list-&gt;tail+1)%MAX == list-&gt;head)代码，为了很好的区分存储空间是否满和是否是空，队列顺序循环存储给tail指针留有一个存储元素的位置来进行区分，这种方式极好的减少删除的时间复杂度，但是还是无法避免顺序存储结构空间不足的问题。 03-队列的链式存储和之前的线性表一样，队列的链式存储可以避免内存不足的问题，接下来我们看下代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct QNode&#123; int data; struct QNode *next;&#125;Node;typedef struct QList&#123; Node *head; Node *tail;&#125;List;List *initList()&#123; List *list = malloc(sizeof(List)); Node *headNode = malloc(sizeof(Node)); headNode-&gt;next = NULL; list-&gt;head = headNode; list-&gt;tail = headNode; return list;&#125;void insertNode(List *list,int val)&#123; Node *node = malloc(sizeof(Node)); if (!node)&#123; printf("分配内存空间失败"); &#125; else &#123; node-&gt;data = val; node-&gt;next = NULL; list-&gt;tail-&gt;next = node; list-&gt;tail = node; &#125;&#125;void printList(List *list)&#123; Node *head = list-&gt;head; Node *node = head-&gt;next; if (!node)&#123; printf("栈链表为空\n"); &#125; else &#123; while(node)&#123; printf("value:%d \n",node-&gt;data); node = node-&gt;next; &#125; &#125;&#125;int main()&#123; List *list = initList(); insertNode(list,1); insertNode(list,2); insertNode(list,3); printList(list); return 0;&#125; github代码]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈的存储结构]]></title>
    <url>%2F2019%2F07%2F17%2Falgorithm%2F%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[栈是一种特殊的线性表，只能在表尾删除或删除元素，表尾称之为栈顶，表头称之为栈底。添加一般叫压栈，删除叫出栈或弹栈，接下来我们看下栈的存储结构 栈的顺序存储1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 10typedef struct&#123; char data[MAXSIZE]; int top;&#125;Stack;void printStack(Stack *stack)&#123; int top = stack-&gt;top; while(top &gt;= 0) &#123; printf("top:%d的值是:%c\n",top,stack-&gt;data[top]); top--; &#125;&#125;void push(Stack *stack,char c)&#123; stack-&gt;top++; stack-&gt;data[stack-&gt;top] = c;&#125;void pop(Stack *stack)&#123; stack-&gt;data[stack-&gt;top] = '\0'; stack-&gt;top--;&#125;int main()&#123; Stack stack = &#123;"abcdef",5&#125;; printf("push前\n"); printStack(&amp;stack); printf("push后\n"); push(&amp;stack,'g'); printStack(&amp;stack); printf("pop后\n"); pop(&amp;stack); printStack(&amp;stack); return 0;&#125; 栈的顺序存储时间复杂度是O(1),内存空间不好把握，容易造成内存不够或浪费。 栈的共享存储123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 10typedef struct&#123; char data[MAXSIZE]; int top1; int top2;&#125;Stack;int isFull(Stack *stack)&#123; if (stack-&gt;top1+1 == stack-&gt;top2)&#123; return 1; &#125; else &#123; return 0; &#125;&#125;void printStack(Stack *stack)&#123; int top1 = stack-&gt;top1; while(top1 &gt;= 0) &#123; printf("top:%d的值是:%c\n",top1,stack-&gt;data[top1]); top1--; &#125; int top2 = stack-&gt;top2; while(top2 &lt; MAXSIZE) &#123; printf("top:%d的值是:%c\n",top2,stack-&gt;data[top2]); top2++; &#125;&#125;void push(Stack *stack,char c, int stackNumber)&#123; if (isFull(stack)) &#123; printf("栈已满"); exit(-1); &#125; if (stackNumber == 1) &#123; stack-&gt;top1++; stack-&gt;data[stack-&gt;top1] = c; &#125; else &#123; stack-&gt;top2--; stack-&gt;data[stack-&gt;top2] = c; &#125;&#125;int main()&#123; Stack stack = &#123;"",-1,MAXSIZE&#125;; printf("push前\n"); printStack(&amp;stack); printf("push后\n"); push(&amp;stack,'a',1); push(&amp;stack,'b',1); push(&amp;stack,'c',2); printStack(&amp;stack); return 0;&#125; 栈的共享存储是对顺序存储的一种补充,在某些特性场景下适合，比如两者的内存大小空间总数是固定的，一方增加一方响应的减少，那么共享存储就比较适合。 栈的链式存储123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node&#123; int data; struct Node *next;&#125;StackNode;typedef struct List&#123; StackNode *top; int count;&#125;StackList;void printStack(StackList *list)&#123; StackNode *temp = list-&gt;top; int index = list-&gt;count; while(temp)&#123; printf("index:%d,data:%d\n",index,temp-&gt;data); temp = temp-&gt;next; index--; &#125;&#125;void push(StackList *list,StackNode *node)&#123; StackNode *temp = list-&gt;top; if (temp) &#123; node-&gt;next = temp; &#125; list-&gt;top = node; list-&gt;count++;&#125;void pop(StackList *list)&#123; StackNode *temp = list-&gt;top; if (temp)&#123; list-&gt;top = list-&gt;top-&gt;next; list-&gt;count --; &#125;&#125;int main()&#123; StackList *list = malloc(sizeof(StackList)); list-&gt;top = NULL; list-&gt;count = 0; printf("push之前\n"); printStack(list); StackNode node1 = &#123;1,NULL&#125;; StackNode node2 = &#123;2,NULL&#125;; StackNode node3 = &#123;3,NULL&#125;; StackNode node4 = &#123;4,NULL&#125;; push(list,&amp;node1); push(list,&amp;node2); push(list,&amp;node3); push(list,&amp;node4); printf("push之后\n"); printStack(list); printf("pop后\n"); pop(list); printStack(list); return 0;&#125; 栈的链式存储避免了存储空间的浪费或内存不足，因为每个节点都有指针也响应增加了一点开销，一般情况下栈的元素不固定就适合用链式存储。 github代码]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVO本质]]></title>
    <url>%2F2019%2F07%2F14%2Fios%2F%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%2FKVO%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[KVO在开发过程中常用于监听对象属性，那么苹果是怎么实现这样一个监听过程的呢，首先我们先看下监听的方法 先定义一个Baby对象123456#import &lt;Foundation/Foundation.h&gt;@interface Baby : NSObject@property (nonatomic,assign) NSInteger age;@end 然后再ViewController中定义两个属性 123456 @interface ViewController ()@property (nonatomic, strong) Baby *by1;@property (nonatomic, strong) Baby *by2;@end 然后再viewDidLoad方法中监听 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 - (void)viewDidLoad &#123; [super viewDidLoad]; self.by1 = [Baby new]; self.by2 = [Baby new]; NSLog(@&quot;添加监听前by1 = %p, by2 = %p&quot;,[self.by1 methodForSelector:@selector(setAge:)],[self.by2 methodForSelector:@selector(setAge:)]); //添加监听前by1 = 0x107c97870, by2 = 0x107c97870 [self.by1 addObserver:self forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew context:nil]; NSLog(@&quot;添加监听后by1 = %p, by2 = %p&quot;,[self.by1 methodForSelector:@selector(setAge:)],[self.by2 methodForSelector:@selector(setAge:)]); //添加监听后by1 = 0x107ff1164, by2 = 0x107c97870 //(lldb) p (IMP)0x107ff1164 //(IMP) $2 = 0x0000000107ff1164 (Foundation`_NSSetLongLongValueAndNotify) NSLog(@&quot;by1 = %@, by2 = %@&quot;,self.by1, self.by2); //(lldb) po self.by1-&gt;isa; NSKVONotifying_Baby //(lldb) po self.by2-&gt;isa; Baby /* 添加监听后runtime会动态创建一个子类NSKVONotifyin_Baby,并同时修该对象的isa指针指向NSKVONotifyin_Baby，其superclass指针指向Baby类,并且NSKVONotifyin_Baby内部一定对setAge方法做了单独的实现 NSKVONotifyin_Baby中的setage方法中其实调用了 Fundation框架中C语言函数 _NSsetIntValueAndNotify，_NSsetIntValueAndNotify内部做的操作相当于，首先调用willChangeValueForKey 将要改变方法，之后调用父类的setage方法对成员变量赋值，最后调用didChangeValueForKey已经改变方法。didChangeValueForKey中会调用监听器的监听方法，最终来到监听者的observeValueForKeyPath方法中。 */ [self printMethods: object_getClass(self.by1)]; [self printMethods: object_getClass(self.by2)]; //(lldb) po object_getClass(self.by1) NSKVONotifying_Baby //(lldb) po [self.by1 class]; Baby //NSKVONotifying_Baby - setAge: class dealloc _isKVOA // class 方法重写直接返回Baby // set方法也重写了 set方法是执行willChangeValueForKey didChangeValueForKey方法 &#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; NSLog(@&quot;observer baby age change %@&quot;,change);&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; self.by1.age ++; self.by2.age ++;&#125;- (void)printMethods:(Class)cls&#123; unsigned int count ; Method *methods = class_copyMethodList(cls, &amp;count); NSMutableString *methodNames = [NSMutableString string]; [methodNames appendFormat:@&quot;%@ - &quot;, cls]; for (int i = 0 ; i &lt; count; i++) &#123; Method method = methods[i]; NSString *methodName = NSStringFromSelector(method_getName(method)); [methodNames appendString: methodName]; [methodNames appendString:@&quot; &quot;]; &#125; NSLog(@&quot;%@&quot;,methodNames); free(methods);&#125; 小结：使用系统的addObserver方法后，runtime动态创建一个NSKVONotifying前缀的子类对象，isa指针开始指向该子类，子类内部重写了set方法，执行set方法的时候会Fundation中NSsetIntValueAndNotify方法，移除执行willChangeValueForKey、set、didChangeValueForKey方法。 github代码]]></content>
      <categories>
        <category>ios</category>
        <category>底层源码</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Class的本质]]></title>
    <url>%2F2019%2F07%2F14%2Fios%2F%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%2FClass%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[我们知道类对象和元类对象都是Class类型，command点击Class类型查看下定义，我们可以看到typedef struct objc_class *Class;，可见Class就是一个指向struct objc_class的指针，那么我们通过runtime源码去继续查找objc_class结构体来进一步查看其结构。 12345678910111213141516171819202122232425262728293031struct objc_object &#123; private: isa_t isa; public: // ISA() assumes this is NOT a tagged pointer object Class ISA(); // getIsa() allows this to be a tagged pointer object Class getIsa(); // 此处省略其他方法细节// object may have associated objects?&#125;;struct objc_class : objc_object &#123;// Class ISA;Class superclass;cache_t cache; // formerly cache pointer and vtableclass_data_bits_t bits; // class_rw_t * plus custom rr/alloc flagsclass_rw_t *data() &#123;return bits.data();&#125;void setData(class_rw_t *newData) &#123;bits.setData(newData);&#125;// 此处省略其他方法细节&#125;; 我们发现objc_object中有一个isa指针，那么objc_class继承objc_object，也就同样拥有一个isa指针，那类中存储的类的成员变量信息，实例方法，属性名等这些信息在哪里呢。 我们看下class_data_bits_t bits;bits1234567struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits; class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125;&#125; bits里面有成员bits，通过位运算得到(class_rw_t *)(bits &amp; FAST_DATA_MASK);得到class_rw_t* data,我们来到class_rw_t中，截取部分代码，我们发现class_rw_t中存储着方法列表，属性列表，协议列表等内容123456789101112struct class_rw_t &#123;// Be warned that Symbolication knows the layout of this structure.uint32_t flags;uint32_t version;const class_ro_t *ro;method_array_t methods; // 方法列表property_array_t properties; // 属性列表protocol_array_t protocols; // 协议列表&#125;; 至此我们大致可以得出，Class指向的结构体objc_object存储了isa、superclass指针及方法列表属性列表和协议列表的信息等，之前断点的时候因为无法查看到某些isa及其他结构体成员，如果有兴趣需要进一步验证的话，可以自建几个结构体来辅助验证下。 github代码]]></content>
      <categories>
        <category>ios</category>
        <category>底层源码</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实例对象类对象元类对象]]></title>
    <url>%2F2019%2F07%2F13%2Fios%2F%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%2F%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[在OC中创建一个普通的实例对象，看似我们创建了一个对象，为了体现和管理类对象实例协议方法等这些关系，OC在底层设计出了三种基本的对象，分别称之为实例对象、类对象、元类对象。 实例对象实例对象就是我们平时用的最多的new、alloc出来的对象 1234NSObject *object1 = [[NSObject alloc] init];NSObject *object2 = [[NSObject alloc] init];NSLog(@"%p %p", object1, object2);// 0x100567bb0 0x100566130 每一次new出来一个实例对象，都是不同的一个内存空间，相互之间是独立的，在之前章节讲过通过clang编译成c/c++代码我们可以出实例对象对应的实例对象的的结构体就是一个isa指针以及成员变量的值，注意这里只是成员变量的值，其他的成员变量的类型信息等都不在这里。 类对象类对象不需要我们手动去创建，这个在我们定义一个类或之前系统定义好的类，在runtime运行过程中，系统就会自动生成类对象，每个类有却对应一个类对象。 1234567891011NSObject *object1 = [[NSObject alloc] init];NSObject *object2 = [[NSObject alloc] init];Class objectClass1 = [object1 class];Class objectClass2 = [object2 class];Class objectClass3 = [NSObject class];// runtimeClass objectClass4 = object_getClass(object1);Class objectClass5 = object_getClass(object2);NSLog(@"%p %p %p %p %p", objectClass1, objectClass2, objectClass3, objectClass4, objectClass5);// 0x7fff9138b140 0x7fff9138b140 0x7fff9138b140 0x7fff9138b140 0x7fff9138b140 通过实例对象或者类调用class方法或者使用runtime的object_getClass都可以获取类的实例对象，通过打印可以看出类对象的地址都是同一个，进一步验证了类对象只有一个。这里类对象对应的c++结构体是储存的是，isa、superclass指针、方法信息、成员变量属性信息、协议等。 元类对象通过runteim的object_getClass方法我们可以获取元类对象1234567891011Student *stu1 = [Student new];Student *stu2 = [Student new];Class stuClass1 = [stu1 class];Class stuClass2 = [stu2 class];Class stuClass3 = [Student class];Class stuClass4 = object_getClass(object1);Class stuClass5 = object_getClass(stu1);Class stuClass6 = object_getClass(stu2);NSLog(@"%p %p %p %p %p %p", stuClass1, stuClass2, stuClass3, stuClass4, stuClass5, stuClass6);// 0x1000025a0 0x1000025a0 0x1000025a0 0x7fff9138b140 0x1000025a0 0x1000025a0 打印结果发现不同实例对象的元类对象同一个，元类对象存储isa、superclass指针、类的类方法信息等 实例对象类对象和元类对象之间的关系三个对象之间各自负责储存这各自的信息，其中贯穿在三者之间的起到相互联系左右的是isa指针。 123456NSObject *object = [[NSObject alloc] init];Class objectClass = [NSObject class];Class objectMetaClass = object_getClass([NSObject class]);NSLog(@"%p %p %p", object, objectClass, objectMetaClass);// 0x100507290 0x7fff9138b140 0x7fff9138b0f0 这是xcode打断点我们试着通过实例对象的isa指针去找下类对象 12345678910(lldb) p/x object-&gt;isa;(Class) $0 = 0x001dffff9a7dc141 NSObject(lldb) p/x object;(NSObject *) $3 = 0x00007fff9a7dc140 NSObject``` 我们发现object-&gt;isa与objectClass的地址不同，这是因为从64bit开始，isa需要进行一次位运算，才能计算出真实地址,位运算的值我们可以通过下载objc源代码找到。```bash(lldb) p/x 0x001dffff9a7dc141 &amp; 0x00007ffffffffff8(long) $7 = 0x00007fff9a7dc140 位运算后得到的object-&gt;isa === objectClass 两个地址完全相等,可见实例对象的isa是指向类对象的，那按照这个思路我们在试试类对象的isa是不是也指向元类对象12(lldb) p/x objectClass-&gt;cls;error: member reference base type 'Class' is not a structure or union 可能是没有暴露出来，为了拿到isa指针的地址，我们自己创建一个同样的结构体并通过强制转化拿到isa指针。12345struct xx_cc_objc_class&#123; Class isa; &#125;;struct xx_cc_objc_class *objectCls2 = (__bridge struct xx_cc_objc_class *)(objectClass);NSLog(@"%p",objectCls2); 我们再重新run一下看看,并断点试试1234(lldb) p/x objectCls2-&gt;isa;(Class) $0 = 0x001dffffa495c0f1(lldb) p/x 0x001dffffa495c0f1 &amp; 0x00007ffffffffff8(long) $1 = 0x00007fffa495c0f0 objectCls2的isa指针经过位运算之后的地址是meta-class的地址,可见类对象的isa是指向原类对象。 小结：这里对实例对象、类对象、元类对象做了简单概括和关系的梳理，需要进步了解三者的关系及内部结构需要查看objc_class内部结构，将在下一章会继续窥探。 github代码]]></content>
      <categories>
        <category>ios</category>
        <category>底层源码</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表-双向链表]]></title>
    <url>%2F2019%2F07%2F12%2Falgorithm%2F%E7%BA%BF%E6%80%A7%E8%A1%A8-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[双向链表的特点是节点可以可以轻易的访问当前元素的前节点或后节点，相对单向链表每个节点多了一个前指针，因此相对要多一些空间的开销，下面我们简单看下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct DNode &#123; int data; struct DNode *prior; struct DNode *next;&#125;;struct DNode *initList()&#123; struct DNode *head = malloc(sizeof(struct DNode)); struct DNode *current = head; struct DNode *previous = NULL; for (int i=0; i&lt;10; i++)&#123; struct DNode *node = malloc(sizeof(struct DNode)); node-&gt;data = i; current-&gt;next = node; current-&gt;prior = previous; previous = current; current = node; &#125; return head;&#125;void printList(struct DNode *head)&#123; struct DNode *current = head-&gt;next; while(current-&gt;next)&#123; printf("data:%d 地址:%p \n",current-&gt;data,current); current = current-&gt;next; &#125;&#125;struct DNode *insert(struct DNode *head,struct DNode *node,int index)&#123; struct DNode *current = head; int i = 0; while(current-&gt;next &amp;&amp; i != index) &#123; current = current-&gt;next; i++; &#125; struct DNode *originNext = current-&gt;next; current-&gt;next = node; node-&gt;prior = current; node-&gt;next = originNext; originNext-&gt;prior = node; return head;&#125;int main()&#123; struct DNode *head = initList(); printf("插入前\n"); printList(head); struct DNode *node = malloc(sizeof(struct DNode)); node-&gt;data = 100; insert(head,node,5); printf("插入后\n"); printList(head); return 0;&#125; 双向链表和单链表基本差不多，所以这里只简单演示了一个插入操作，其他的可参考单链表。 github代码]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>双向链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表-循环链表]]></title>
    <url>%2F2019%2F07%2F11%2Falgorithm%2F%E7%BA%BF%E6%80%A7%E8%A1%A8-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[循环链表是在单链表的基础上做了额外的补充，单链表最后一个尾元素next指针指向NULL，循环链表是指向链表的第一个元素，下面我们来看下代码 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct Node&#123; int data; struct Node *next;&#125;;typedef struct Node CNode;CNode *initCircleList()&#123; CNode *temp = malloc(sizeof(CNode)); CNode *p = temp; for (int i=1; i&lt;3; i++)&#123; CNode *node = malloc(sizeof(CNode)); node-&gt;data = i; temp-&gt;next = node; temp = node; &#125; temp-&gt;next = p-&gt;next; return p;&#125;int main()&#123; CNode *p = initCircleList(); printf("第一个元素：%d 地址: %p\n",p-&gt;next-&gt;data,p-&gt;next); printf("下个元素：%d 地址: %p\n",p-&gt;next-&gt;next-&gt;data,p-&gt;next-&gt;next); printf("下下个元素：%d 地址: %p\n",p-&gt;next-&gt;next-&gt;next-&gt;data,p-&gt;next-&gt;next-&gt;next); return 0;&#125; 然后我们用gcc编译后run一下 12gcc 04-循环链表.c./a.out 得到的输出结果是123第一个元素：1 地址: 0x7f9e3ac02bf0下个元素：2 地址: 0x7f9e3ac02c00下下个元素：1 地址: 0x7f9e3ac02bf0 可见第一个元素和下下个元素地址是一样的，这是因为尾部元素的next指针指向了第一个元素，这就是循环链表的特点，某些情况下还是使用场景的，普通的单链表比如循环遍历的时候必须从第一个元素开始遍历，但是循环链表可以从任一一个元素开始遍历。 github代码]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>循环链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表-静态链表]]></title>
    <url>%2F2019%2F07%2F09%2Falgorithm%2F%E7%BA%BF%E6%80%A7%E8%A1%A8-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[静态链表是基于数组的形式来构建的链表，这种方式可以针对没有指针的情况下，用数组去实现，静态链一般创建一个相对大的数组空间，数组下标0的元素是用来存放备用链的第一个节点下标，最后一个元素则是存放第一个有值元素的下标。 下面我们来分别看看静态链表的增删改查 首先我们定义头部公共部分代码1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define MAXSIZE 1000#define ORIGINSIZE 10typedef struct&#123; char data[50]; int cur;&#125; SNode;SNode sList[MAXSIZE]; 定义的SNode结构体，data是存储元素数据，cur是游标，类似之前单链表的next指针。 静态链表的创建1234567891011void initList(SNode list[])&#123; for (int i=1; i&lt;ORIGINSIZE; i++)&#123; char str[100]; sprintf(str,"%d",i); strcpy(list[i].data,"data"); strcat(list[i].data,str); list[i].cur = i+1; &#125; list[0].cur = ORIGINSIZE+1; list[MAXSIZE-1].cur = 1;&#125; 以上分别对数组的第一个和最后一个元素的游标指向相应的索引 静态链表的查询12345678void printList(SNode list[])&#123; SNode node = list[MAXSIZE-1]; SNode temp = list[node.cur]; while (temp.cur)&#123; printf("%s \n",temp.data); temp = list[temp.cur]; &#125;;&#125; 当cur不为真时说明已经是链表的最后一个元素 静态链表的插入12345678910111213141516171819202122void insert(SNode list[],int index,char data[100])&#123; if (index &lt; 0 || index &gt;= ORIGINSIZE) &#123; printf("插入一个不存在的链表区间"); exit(-1); &#125; int i = list[0].cur; strcpy(list[i].data,data); list[0].cur = list[i].cur; if (index == 0) &#123; int k = list[MAXSIZE-1].cur; list[i].cur = k; list[MAXSIZE-1].cur = i; &#125; else &#123; int k = list[MAXSIZE-1].cur; for (int j=1; j &lt; index; j++)&#123; k = list[k].cur; &#125; list[i].cur = list[k].cur; list[k].cur = i; &#125; &#125; 静态链表的删除12345678910111213141516171819void delete(SNode list[],int index)&#123; if (index &lt; 0 || index &gt;= ORIGINSIZE) &#123; printf("删除的是一个不存在的链表区间"); exit(-1); &#125; int temp = MAXSIZE-1; // 最后一位元素的索引 for (int i=0; i&lt;index; i++)&#123; temp = list[temp].cur; // 上一位的元素索引 &#125; int currentIndex = list[temp].cur; // 这里需要暂存当前元素的索引 SNode node = list[list[temp].cur]; // 删除的节点 int nextTemp = node.cur; // 下一位的元素索引 list[temp].cur = nextTemp; // 上一位元素指针指向下一位元素的索引 // 接下来处理备用空间 strcpy(node.data,""); node.cur = list[0].cur; // 删除的节点指向原来的第一个备用节点 list[0].cur = currentIndex; // 备用节点执行当前删除节点的索引&#125; 小结：在插入和删除操作方面，静态链表类似单链表的所以相对顺序存储是有性能优势，存取没有没有顺序存储方便。同时静态链表的长度也存在难以确定的问题。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法 线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表-链式存储]]></title>
    <url>%2F2019%2F07%2F09%2Falgorithm%2F%E7%BA%BF%E6%80%A7%E8%A1%A8-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[线性表的链式存储，存储顺序基本可连续可不连续，数据元素可以在内存的任意位置，每个元素大致包含两部分一部分是数据区用来存储元素数据，一部分是指针区用来指向下一个元素的地址，依次来实现一个链式存储。因为每个元素只包含一个指针，我们也称之为单链表。为了区分链表的起始位置，一般单链表会设置一个头结点或者头指针指向第一个起点元素，然后最后一个元素的指针指向NULL。 下面我们来通过增删改查的方式来看看单链表的结构 创建单链表创建方式可以有很多种，我们这里举例头部和尾部插入的方法1234567891011121314151617181920212223242526// 头部插入创建链式表struct Node * createChainListByHead()&#123; struct Node *p; struct Node * headNode = malloc(sizeof(struct Node)); headNode-&gt;next = NULL; for (int i=0; i&lt;10; i++)&#123; p = malloc(sizeof(struct Node)); p-&gt;data = rand()%100+1; p-&gt;next = headNode-&gt;next; headNode-&gt;next = p; &#125; return headNode;&#125;// 尾部插入创建链式表void createChainListByTail()&#123; struct Node *p; struct Node *current = malloc(sizeof(struct Node)); for (int i=0; i&lt;10; i++)&#123; p = malloc(sizeof(struct Node)); p-&gt;data = rand()%100+1; current-&gt;next = p; current = p; &#125; current-&gt;next = NULL;&#125; 查询单链表所有元素123456789// 获取所有链式表元素void printAllOfElements(struct Node *head)&#123; struct Node * temp = head-&gt;next; while (temp)&#123; int data = temp-&gt;data; printf("%d \n",data); temp = temp-&gt;next; &#125;;&#125; 向链表插入某个元素1234567891011121314151617181920// 插入元素void insertElement(int index, struct Node * node)&#123; struct Node * head = createChainListByHead(); printf("插入前\n"); printAllOfElements(head); struct Node * temp = head; int i = 0; while (i &lt; index)&#123; if (temp-&gt;next) &#123; temp = temp-&gt;next; i++; &#125; else &#123; break; &#125; &#125;; node-&gt;next = temp-&gt;next; temp-&gt;next = node; printf("插入后\n"); printAllOfElements(head);&#125; 删除链表中的某个元素123456789101112131415161718192021// 删除链表中的某个元素void deleteElement(int index)&#123; struct Node * head = createChainListByHead(); printf("删除前\n"); printAllOfElements(head); struct Node * temp = head; int i = 0; while(i &lt; index) &#123; temp = temp-&gt;next; i++; &#125; if (temp-&gt;next) &#123; struct Node *next = temp-&gt;next; temp-&gt;next = next-&gt;next; &#125; else &#123; printf("不存在链表的区间中"); exit(-1); &#125; printf("删除后\n"); printAllOfElements(head);&#125; 不难发现，对比顺序存储，链式存储的算法插入和删除操作的时间复杂O(n)效率是更优的。 github代码]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法 线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表-顺序存储]]></title>
    <url>%2F2019%2F07%2F05%2Falgorithm%2F%E7%BA%BF%E6%80%A7%E8%A1%A8-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[线性表顺序存储，是按照一段联系的内存单元依次存储数据元素，这里我们可以使用一位数组来表示。 下面我们使用c代码来实现下顺序存储的增删改查等操作,首先我们先定义一个LineTable.h文件里面定义一个线性表的结构体及简单的断言方法,以供增删改查使用 LineTabel.h12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX 10struct LineTable &#123; char data[MAX]; int length;&#125;;void queryassert(int index, struct LineTable list)&#123; if (index &lt; 0 || index &gt;= list.length) &#123; printf("%d超出了线性表的范围",index); exit(-1); &#125;&#125;void insertassert(int index, struct LineTable list)&#123; if (list.length == MAX) &#123; printf("线性表已满"); exit(-1); &#125; if (index &lt; 0 || index &gt; list.length) &#123; printf("%d超出了线性表的范围",index); exit(-1); &#125;&#125; 查找元素1234567891011121314151617#include "LineTable.h"struct LineTable lineTable = &#123;"abcdefghig",10&#125;;char getElementByIndex(index)&#123; queryassert(index,lineTable); return lineTable.data[index];&#125;int main()&#123; char element = getElementByIndex(20); printf("获取的元素是%c",element); return 0;&#125; 通过以上代码可以发现，线性表的顺序存储方式对于查找元素是很方便的，时间复杂度只有O(1)。 插入元素12345678910111213141516171819202122#include "LineTable.h"struct LineTable lineTable = &#123;"abcde",5&#125;;void insert(int index, char c)&#123; insertassert(index,lineTable); if (index &lt; lineTable.length) &#123; for (int k = index; k &lt; lineTable.length; k++)&#123; lineTable.data[k+1] = lineTable.data[k]; &#125; &#125; lineTable.data[index] = c; lineTable.length ++;&#125;int main()&#123; insert(5,'y'); printf("插入后的线性表数据是%s,长度是%d",lineTable.data,lineTable.length); return 0;&#125; 插入操作相对查找是要复杂点，根据插入位置不同时间复杂度也不同，O(1)至O(n)，平均时间复杂度(n-1)/2,按时间复杂度计算原则，算是O(n)，另外还有删除操作，有时间的可以试试，基本和插入类似是一个反向操作。 可见线性表的顺序存储结构中，因为有固有的顺序所以查找是很方便的，但是修改删除还是相对麻烦的，基本上是修改删除一个元素就要移动大多数其他元素，另外当线性表长度很长时，难以确认储存空间容量及寻找一段很长的连续的存储空间。 github代码]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法 线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel7 入门]]></title>
    <url>%2F2019%2F06%2F17%2Fjs%2Fbabel%2Fbabel-core%2F</url>
    <content type="text"><![CDATA[@bable/core@bable/core是babel7的核心包，主要对提供对代码的语法词法分析及转换的方法 首先npm安装下@bable/core包1npm install @babel/core --save-dev 我们下简单看下@bable/core提供的几个核心方法 index00.js1234const babel = require("@babel/core");var parsedAst = babel.parse('const demofunc0 = res =&gt; &#123;console.log("func 0")&#125;', &#123;&#125;);console.log(parsedAst); 打印出来就是AST语法树12345678910111213141516171819Node &#123; type: &apos;File&apos;, start: 0, end: 46, loc: SourceLocation &#123; start: Position &#123; line: 1, column: 0 &#125;, end: Position &#123; line: 1, column: 46 &#125; &#125;, program: Node &#123; type: &apos;Program&apos;, start: 0, end: 46, loc: SourceLocation &#123; start: [Position], end: [Position] &#125;, sourceType: &apos;module&apos;, interpreter: null, body: [ [Node] ], directives: [] &#125;, comments: [] &#125; 接着我们对AST进行转换操作12var result = babel.transformFromAstSync(parsedAst, &#123;&#125;);console.log("result",result); 打印出后的代码12345678910111213141516171819202122232425262728&#123; metadata: &#123;&#125;, options: &#123; babelrc: false, configFile: false, passPerPreset: false, envName: 'development', cwd: '/Users/xxxx/learn/js/study/study-babel', root: '/Users/xxxx/learn/js/study/study-babel', plugins: [], presets: [], parserOpts: &#123; sourceType: 'module', sourceFileName: undefined, plugins: [] &#125;, generatorOpts: &#123; filename: undefined, auxiliaryCommentBefore: undefined, auxiliaryCommentAfter: undefined, retainLines: undefined, comments: true, shouldPrintComment: undefined, compact: 'auto', minified: undefined, sourceMaps: false, sourceRoot: undefined, sourceFileName: 'unknown' &#125; &#125;, ast: null, code: 'var demofunc0 = res =&gt; &#123;\n console.log("func 0");\n&#125;;', map: null, sourceType: 'module' &#125; 可见AST又被转换还原成了之前箭头方法code: &#39;var demofunc0 = res =&gt; {\n console.log(&quot;func 0&quot;);\n}; 下面我们通过babel提供命令行工具来执行验证下@babel/core 首先我们先安装下@babel-cli1npm install --save-dev @babel/cli 然后执行终端命令1234567npx babel ./examples/01/code01/src/index01.js --out...const demofunc1 = res =&gt; &#123; console.log("func 1");&#125;;... 默认的在终端执行babel –out方法实际也就是@babel/core对代码进行了parse和transform，bable/core只提供核心方法，具体要要怎么转换要做什么具体工作都又插件来完成，因为没有做任何的参数插件配置，所以代码还是返回原来的代码。 @babel/plugin-transform-arrow-functions接下来我们试试使用插件后的效果比如我们将es6的箭头函数转成普通的函数 123456789npm install --save @babel/plugin-transform-arrow-functionsnpx babel ./examples/01/code01/src/index02.js --out --plugins=@babel/plugin-transform-arrow-functions...const demofunc2 = function (res) &#123; console.log("func 2");&#125;;... @babel/plugin-transform-classes另外还有es6新增的class定义 123456789101112131415161718192021222324252627282930313233343536npm install --save-dev @babel/plugin-transform-classesnpx babel ./examples/01/code01/src/index03.js --out --plugins=@babel/plugin-transform-classes...function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError("Cannot call a class as a function"); &#125; &#125;function _defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125;function _createClass(Constructor, protoProps, staticProps) &#123; if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; &#125;let Person =/*#__PURE__*/function () &#123; function Person(name) &#123; _classCallCheck(this, Person); this.name = name; &#125; _createClass(Person, [&#123; key: "sing", value: function sing() &#123; console.log(this.name + 'is singing'); &#125; &#125;]); return Person;&#125;();const demofunc5 = res =&gt; &#123; console.log("func 5");&#125;;var p = new Person("xiao wang");p.sing();... @babel/preset-envbabel的插件有很多，如果我们每个插件都逐一添加确实比较麻烦，这时候@babel/preset-env就是用来解决这一繁琐工作的。 配置下.babelrc12345&#123; "presets": [ ["@babel/preset-env"] ]&#125; 安装preset-env并执行babel1234567891011121314151617181920212223242526272829303132333435363738npx babel ./examples/01/code01/src/index04.js --out --preset=@babel/preset-envnpx babel ./examples/01/code01/src/index04.js..."use strict";function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError("Cannot call a class as a function"); &#125; &#125;function _defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125;function _createClass(Constructor, protoProps, staticProps) &#123; if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; &#125;var Person =/*#__PURE__*/function () &#123; function Person(name) &#123; _classCallCheck(this, Person); this.name = name; &#125; _createClass(Person, [&#123; key: "sing", value: function sing() &#123; console.log(this.name + 'is singing'); &#125; &#125;]); return Person;&#125;();var demofunc4 = function demofunc4(res) &#123; console.log("func 4");&#125;;var p = new Person("xiao wang");p.sing();... .babelrc默认不配置情况下是babel-preset-es2015, babel-preset-es2016, and babel-preset-es2017的集合，所以class和箭头函数都会转换。 接下来我们稍微做下改动1234567891011&#123; "presets": [ ["@babel/preset-env", &#123; "targets": &#123; "node": "10" &#125; &#125; ] ]&#125; 1234567891011121314151617181920212223npx babel ./examples/01/code01/src/index04.js..."use strict";class Person &#123; constructor(name) &#123; this.name = name; &#125; sing() &#123; console.log(this.name + 'is singing'); &#125;&#125;const demofunc4 = res =&gt; &#123; console.log("func 4");&#125;;var p = new Person("xiao wang");p.sing();... 这时候代码是原样输出，这是因为@babel/preset-env对输出环境做了预判，@babel/preset-env会检查代码是否可以在node10上可以正常运行，node10是否有代码中的特性，如果有那么babel就会原样输出，如果没有那么babel就会将其转换成老的方法特性做到兼容。 @babel/ployfill那么是不是有了@babel/preset-env这样我们就兼容我们想要兼容的所有浏览器环境呢，然而并非如此，@babel/preset-env只将不同版本的写法，高版本转化为低版本，保证正确统一的语义，并不会去增加或修改原有的方法或属性，有些新增方法全局或原型方法在不同浏览器环境的不同，则需要@babel/ployfill来做兼容 我们首先来看下没有polyfill的情况 .babelrc1234567891011&#123; "presets": [ ["@babel/preset-env", &#123; "targets": &#123; "chrome": "15" &#125; &#125; ] ]&#125; 12345678910111213141516171819npx babel ./examples/01/code01/src/index05.js..."use strict";var demofunc5 = function demofunc5(res) &#123; console.log("func 5");&#125;;var data = Object.assign(&#123; age: 18&#125;, &#123; name: 'carvetime'&#125;);var jsonData = JSON.stringify(data);alert.log(data);... 我们发现箭头函数被转成了普通的js函数，但是Object.assign放并没有进行转换，这是es6新增的方法，babel并不进行兼容处理，下面我们来尝试下polyfill。 先安装下polyfill，这里需要注意，是安装在生产环境，polyfill是在浏览器环境运行时才加载的，所以和其他的开发环境编译有所不同1npm install --save @babel/polyfill .babelrc12345678910111213&#123; "presets": [ ["@babel/preset-env", &#123; "targets": &#123; "firefox": "15" &#125;, "useBuiltIns": "usage" &#125;, ] ]&#125; 然后执行下编译123456789101112131415161718192021222324npx babel ./examples/01/code01/src/index05.js...WARNING: We noticed you&apos;re using the `useBuiltIns` option without declaring a core-js version. Currently, we assume version 2.x when no version is passed. Since this default version will likely change in future versions of Babel, we recommend explicitly setting the core-js version you are using via the `corejs` option.&quot;use strict&quot;;require(&quot;core-js/modules/es6.object.assign&quot;);var demofunc5 = function demofunc5(res) &#123; console.log(&quot;func 5&quot;);&#125;;var data = Object.assign(&#123; age: 18&#125;, &#123; name: &apos;carvetime&apos;&#125;);var jsonData = JSON.stringify(data);alert.log(data);... babel7开始使用&quot;useBuiltIns&quot;: &quot;usage&quot;就可以使用polyfill功能，通过警告可知polyfill功能放到core-js里面啦,默认不配置的话是core-js2，我们再稍微改下 1npm install --save core-js@2 因为需要在运行时环境require core-js我们这时候需要用webpack打包以支持commonjs，所以我们先配置下webpack.config.js1234567891011121314151617181920212223const path = require(&apos;path&apos;)const &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; entry: &apos;./examples/01/code01/src/index05.js&apos;, mode: &quot;development&quot;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin() ], output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(__dirname, &apos;./examples/01/code01/dist&apos;) &#125;, module: &#123; rules: [ &#123; test: /\.js$/, exclude: /node_modules/, loader: &quot;babel-loader&quot; &#125; ] &#125;&#125; 最后我们再运行下webapck1npx webpack 此时用用mac电脑最新版的Chrome(版本号74)浏览器打开dist/index.html文件会提示一个弹框This page says {&quot;age&quot;:18,&quot;name&quot;:&quot;carvetime&quot;},用Firefox(版本号15)打开也是显示弹窗{&quot;age&quot;:18,&quot;name&quot;:&quot;carvetime&quot;}，因为此时我们配置的&quot;targets&quot;: {&quot;firefox&quot;: &quot;15&quot;}，所以能在Firefox老版本15上运行，那么最新版本Chrome肯定也是能正常运行。 我们看下dist/bundle.js的部分代码12345678__webpack_require__.r(__webpack_exports__);var core_js_modules_es6_object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/core-js/modules/es6.object.assign.js");var core_js_modules_es6_object_assign__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(core_js_modules_es6_object_assign__WEBPACK_IMPORTED_MODULE_0__);var demofunc5 = function demofunc5(res) &#123; console.log("func 5");&#125;;var data = Object.assign(&#123; age: 18&#125;, &#123; name: 'carvetime'&#125;);var jsonData = JSON.stringify(data); alert(jsonData); 不难发现，箭头函数转成了普通函数，require了es6.object.assign的方法，所以两个不同版本的浏览器都可以正常运行。 接下来我们稍微改动下配置&quot;targets&quot;: {&quot;firefox&quot;: &quot;64&quot;}，我们再npx webpack一次，然后分别刷新两个浏览器此时，Chrome还是正常弹窗，而老版本的Firefox则报错SyntaxError: syntax error const demofunc5 = res =&gt; {，因为此时我们制定在Firefox64的版本上可以运行，因为Firefox64的版本是支持箭头函数的，所以此时不会转换箭头函数，在Firefox15老版本浏览器上不支持新箭头语法因此会报错 我们再看下dist/bundle.js的部分代码1234const demofunc5 = res =&gt; &#123; console.log("func 5");&#125;;var data = Object.assign(&#123; age: 18&#125;, &#123; name: 'carvetime'&#125;);var jsonData = JSON.stringify(data);\nalert(jsonData); 这时候代码是原样输出，没有箭头函数转换也没有引入core的Object.assign的的方法，所以老版本会包箭头函数语法错误，那么我们再去掉箭头函数再编译下看看dist/bundle.js文件部分代码12var data = Object.assign(&#123; age: 18&#125;, &#123; name: 'carvetime'&#125;);var jsonData = JSON.stringify(data);\nalert(jsonData); 这时候Firefox15的浏览器报还是报错Object.assign is not a function,也是一样的原因，因为Object.assign是es6新增的方法，因为我们配置&quot;targets&quot;: {&quot;firefox&quot;: &quot;64&quot;}是支持Firefox64，在火狐64上是支持有这个Object方法的，所以编译出来的代码还是原样，导致老版本浏览器中就会无法识别这个方法。 @babel/runtime我们先对src/index06.js编译下看1npx babel ./examples/01/code01/src/index06.js 产生如下代码123456789101112131415161718192021222324252627282930313233"use strict";function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError("Cannot call a class as a function"); &#125; &#125;function _defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125;function _createClass(Constructor, protoProps, staticProps) &#123; if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; &#125;var Person =/*#__PURE__*/function () &#123; function Person(name) &#123; _classCallCheck(this, Person); this.name = name; &#125; _createClass(Person, [&#123; key: "sing", value: function sing() &#123; console.log(this.name + 'is singing'); &#125; &#125;]); return Person;&#125;();var demofunc6 = function demofunc6(res) &#123; console.log("func 6");&#125;;var p = new Person("xiao wang");p.sing(); 可见针对es6的class新语法，babel专门定义可_classCallCheck,_defineProperties,_createClass等help工具方法协助转换成老的class方法，如果文件我们生产多个文件的话就可以每个文件都包含这些help方法，这时候@babel/plugin-transform-runtime就出现了，它可以用require的方式引入模块里的helper方法从而避免了代码的冗余重复。 我们先安装下@babel/plugin-transform-runtime1npm install --save-dev @babel/plugin-transform-runtime 接着我们配置下.babelrc12345678910111213141516&#123; "presets": [ ["@babel/preset-env", &#123; "targets": &#123; "firefox": "15" &#125;, "useBuiltIns": "usage" &#125;, ] ], "plugins": [ "@babel/plugin-transform-runtime" ]&#125; 最后run一下1npx babel ./examples/01/code01/src/index06.js 看下输出结果12345678910111213141516171819202122232425262728293031"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));var Person =/*#__PURE__*/function () &#123; function Person(name) &#123; (0, _classCallCheck2.default)(this, Person); this.name = name; &#125; (0, _createClass2.default)(Person, [&#123; key: "sing", value: function sing() &#123; console.log(this.name + 'is singing'); &#125; &#125;]); return Person;&#125;();var demofunc6 = function demofunc6(res) &#123; console.log("func 6");&#125;;var p = new Person("xiao wang");p.sing(); 对比代码发现，代码确实少了很多，_classCallCheck,_defineProperties,_createClass也都是直接从模块引入，我们试试用webpack试试在浏览器上是否可以正常运行。 123456npx webpack...ERROR in ./examples/01/code01/src/index06.jsModule not found: Error: Can't resolve '@babel/runtime/helpers/classCallCheck'... 此时运行webpack会报错提示找不到@babel/runtime/helpers/createClass模块，这时候我们就需要另外一个插件@babel/runtime,@babel/plugin-transform-runtime是帮我们根据环境条件require相应的模块方法，但是所以的help方法都统一存放在@babel/runtime中,那么我们先安装下 1npm install --save-pro @babel/runtime 这里需要注意下，@babel/runtime不是和之前插件一样安装在开发依赖中，之前很多插件都是在开环环境中编译，但这个@babel/runtime是在运行时生产环境中具体需要require的，所以肯定是需要安装在生成环境中，接着我们再npx webpack下，这时候成功运行，我们再查看下src/bundle.js 1234567891011121314151617181920eval("__webpack_require__.r(__webpack_exports__); var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"); var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js");var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);var Person = function () &#123; function Person(name) &#123; _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, Person); this.name = name; &#125;_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()( Person, [&#123; key: "sing", value: function sing() &#123; console.log(this.name + ' is singing'); &#125;&#125; ]); return Person; &#125;(); var demofunc6 = function demofunc6(res) &#123; console.log("func 6");&#125;; var p = new Person("xiao wang6"); p.sing();); 这样方法做到了复用bundle.js的代码量明显减少，如果多个文件就只共引用一份helper代码，然后两个新老版本都可以正常弹窗alertxiao wang6 is singing @babel/runtime-corejs2这时候我们再在index.js Person里面加一个es6的新增的方法看看1234info()&#123; var data = Object.assign(&#123;age:18&#125;,&#123;name:&apos;carvetime&apos;&#125;); alert(JSON.stringify(data))&#125; npx webpack运行再在浏览器打开，发现低版本的Firefox15报错显示TypeError: Object.assign is not a function，查阅官方文档我们发现 We have separated out Babel’s helpers from it’s “polyfilling” behavior in runtime. More details in the PR.@babel/runtime now only contains the helpers, and if you need core-js you can use @babel/runtime-corejs2 and the option provided in the transform. For both you still need the @babel/plugin-transform-runtime 可见es6新增的全局原型等方法polyfill这一块代码已经从runtime中分离出来，需要实现polyfill功能必须安装@babel/runtime-corejs2，我们来试试1npm install @babel/runtime-corejs2 同时我们修改下.babelrc12345678&#123; "plugins": [- ["@babel/plugin-transform-runtime"],+ ["@babel/plugin-transform-runtime", &#123;+ "corejs": 2,+ &#125;], ]&#125; 这时候我们再来运行下npx webpack,我们来看下dist/bundle.js文件123456__webpack_require__.r(__webpack_exports__);+ /* harmony import */ var + _babel_runtime_corejs2_core_js_json_stringify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime-corejs2/core-js/json/stringify */ "./node_modules/@babel/runtime-corejs2/core-js/json/stringify.js");++ /* harmony import */ var ++ _babel_runtime_corejs2_core_js_json_stringify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs2_core_js_json_stringify__WEBPACK_IMPORTED_MODULE_0__);+ /* harmony import */ var _babel_runtime_corejs2_core_js_object_assign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime-corejs2/core-js/object/assign */ "./node_modules/@babel/runtime-corejs2/core-js/object/assign.js");++ /* harmony import */ var _babel_runtime_corejs2_core_js_object_assign__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs2_core_js_object_assign__WEBPACK_IMPORTED_MODULE_1__); 相比之前新增了stringify，assign的方法，然后我们再用新来版本浏览器打开发现都可以正常弹框，没有任何异常。 useBuiltIns持外babel7提供了另外一个按需导入polyfill的方法useBuiltIns: &quot;usage&quot;我们也来试试 .babelrc123456789101112131415&#123; "presets": [ ["@babel/preset-env", &#123; "targets": &#123; "firefox": "15" &#125;, "corejs": 2, "useBuiltIns": "usage", "debug": true &#125;, ] ]&#125; 然后npx webpack运行到高低版本浏览器上都可以正常显示 思考问题：那我们平时应该是用@babel/plugin-transform-runtime 还是用useBuiltIns方法来引入ployfill呢?。 github代码]]></content>
      <categories>
        <category>babel</category>
        <category>babel7 入门</category>
      </categories>
      <tags>
        <tag>babel7 入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell 06 输入输出]]></title>
    <url>%2F2019%2F06%2F07%2Fbase%2Fshell%2Fshell-06-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[shell默认的输入和输出都是终端，linux启动后会默认有三个文件描述分别是标准输入0，正确输出1，异常输出2 输出我们试下简单的输入一段文本到制定的文件123456filepath='./examples/06/source/users''hello shell' &gt; $filepathcat $filepath...hello shell... &gt;文件不存在时会创建一个，如果存在也会覆盖之前内容12345echo "hello shell 2" &gt; $filepathcat $filepath...hello shell 2... &gt;&gt;只是追加内容在原文件内容后面123456echo "hello shell 3" &gt;&gt; $filepathcat $filepath...hello shell 2hello shell 3... 输入一般情况的shell输入终端键盘输入，我们现在讲输入重定向到文件12345678910111213notfoundPath = './examples/06/source/test'filepath='./examples/06/source/users'echo 'hello shell' &gt; $filepathecho "hello shell 2" &gt; $filepathecho "hello shell 3" &gt;&gt; $filepath# 文件作为输入cat &lt; $filepath...hello shell 2hello shell 3... 异常输出我们看下异常的输出12345678notfoundPath=''filepath='./examples/06/source/users'cat notfoundPath &gt; $filepath...cat: notfoundPath: No such file or directory# users 内容是空... 这时候报错会默认输出到终端屏幕 接下来我们将报错输入到文件中1234notfoundPath=&apos;&apos;cat notfoundPath 1&gt; $filepath 2&gt; &apos;./examples/06/source/error&apos; # 此时多出一个error的文件里面的内容是 cat: notfoundPath: No such file or directory 1&gt;表示标注输出到filepath中，2&gt;表示错误输出到error中 12345notfoundPath=''filepath='./examples/06/source/users'cat notfoundPath &gt; $filepath 2&gt;&amp;1#终端输出是空，users内容是cat: notfoundPath: No such file or directory &gt;没写1或2的话默认是1，表示标准输出到filepath中，后面的2&gt;&amp;1代表错误输出按照正确输出1的路径输出 /dev/null类似一个垃圾箱，我们将所有的正确输出和异常输出都交给它12notfoundPath=&apos;&apos;cat notfoundPath &gt; /dev/null 2&gt;&amp;1 这时候我们在终端屏幕及任何文件中都看不到任何的输出信息]]></content>
      <categories>
        <category>基础</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell 01 起步]]></title>
    <url>%2F2019%2F06%2F07%2Fbase%2Fshell%2Fshell-01-%E8%B5%B7%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[shell是c语言编写的用于用户与Linux建立直接操作的接口程序，它遵循一定的语法将命令解释传递给系统，同时将shell语法各种指令集合成纯文本我们称shell脚本。shell 又常分 Bourne shell (sh), C shell (csh), 和 Korn shell (ksh) 三种shell。本次我们学习的是Bourne Again shell (bash)，bash是基于sh的扩展，在sh的基础上，bash增加了命令行补齐、通配符、输入输出重定向、管道、提示符、作业控制等功能 我们先简单写个shell脚本 01-含解释器.sh12#!bin/bashecho "Hello Bash" 运行shell脚本有两种方式 作为可执行程序我们向终端添加执行权限并执行脚本123chmod +x ./examples/01/code/01-含解释器.sh./examples/01/code/01-含解释器.sh 执行的时候需要是脚本的地址，不能直接01-含解释器.sh，否则linux 系统会去 PATH 里找，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里。 作为解释器参数这里我们直接运行解释器 02-不含解释器.sh12chmod +x ./examples/01/code/02-不含解释器.sh/bin/bash ./examples/01/code/02-不含解释器.sh 这种方式运行的脚本，不需要在第一行指定解释器信息 注释bash和大多数语言一样也是有单行和多行注释 03-注释.sh123456789101112131415161718192021222324252627#!/bin/bash# 单行注释# echo &quot;单行注释&quot;# 多行注释1:&lt;&lt;EOFecho &quot;多行注释&quot;echo &quot;多行注释&quot;echo &quot;多行注释&quot;EOF# 多行注释2:&lt;&lt;!echo &quot;多行注释&quot;echo &quot;多行注释&quot;echo &quot;多行注释&quot;!# 多行注释3&apos;:&lt;&lt;echo &quot;多行注释&quot;echo &quot;多行注释&quot;echo &quot;多行注释&quot;&apos; echo命令1234567891011121314151617181920212223242526#!/bin/bashecho "there is a log"echo there is a logecho "her name is \"wendell\""echo -e "文字太长了我需要换行，我到下一行再说 \n 我排到第二行啦"echo -e "文字太长了我需要换行，但是我坚决不换号\c 我还在第一行"echo "文字宝贵需要输出到文件上" &gt; "./examples/01/source/01.txt"read nameecho "welcome $name"...there is a logthere is a logher name is "wendell"文字太长了我需要换行，我到下一行再说 我排到第二行啦文字太长了我需要换行，但是我坚决不换号welcome carvetime... printfprintf 命令模仿 C 程序库（library）里的 printf() 程序,printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好,同事可以格式化定制字符串宽度等。 12345678910111213141516171819#!/bin/bashecho "默认我会换行的"printf "默认我不会换行的"echo "结束啦"printf "%-20s %-10s\n" 姓名 分数printf "%-20s %-10.2f\n" xiaoli 99.6444printf "%-20s %-10.2f\n" xiaowang 90.444# %-20s %s %c %d %f都是格式替代符，-代表左对齐，%-10.2f .2代表保留2位小数# 没有引号也可以输出printf %s hello# 格式只制定了一个后面的world会重用之前的%sprintf %s hello world 函数12345678910111213141516171819202122232425262728#!/bin/bashfunc1()&#123; echo '执行shell方法 没有返回值'&#125;func2()&#123; echo '有返回值' return 1&#125;func3()&#123; echo "第一个参数是 $1" # echo "第是十一个参数是 $11" 两位数的需使用$&#123;&#125; echo "第是十一个参数是 $&#123;11&#125;"&#125;func1func2func3 1 2 3 4 5 6 7 8 9 10 11 12echo "func2返回值是$?"...执行shell方法 没有返回值有返回值第一个参数是 1第是十一个参数是 11func2返回值是0...]]></content>
      <categories>
        <category>基础</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell 02 变量]]></title>
    <url>%2F2019%2F06%2F07%2Fbase%2Fshell%2Fshell-02-%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[bash的变量声明不需要加任何表示符,命名规则和大多数编程语言差不多 命名必须是英文字母，数字和下划线，首个字符不能以数字开头中间不能有空格，不能可以用标点符号，不可以用bash的关键字 变量的声明01.sh12345678910#!/bin/bashname=&quot;carvetime&quot;echo $&#123;name&#125;echo &quot;my name is $&#123;name&#125;&quot;...carvetimemy name is carvetime... 注意声明赋值中间不能有空格name = &quot;carvetime&quot;这样就会报错,这里变量的echo有点类似javascript的console.log的反斜杠 02.sh 1234567891011#!/bin/bashname="carvetime"echo $&#123;name&#125;name="carvetime2"echo $&#123;name&#125;...carvetimecarvetime2... 可见变量可以重新赋值,重新赋值的时候还是和申明赋值一样的 声明只读变量使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变 03.sh123456789#!/bin/bashname=&apos;carvetime&apos;readonly namename=&apos;carvetime2&apos;..../examples/02/code/03.sh: line 5: name: readonly variable... 删除变量使用 unset 命令可以删除变量04.sh12345678910#!/bin/bashname=&quot;carvetime&quot;unset nameecho $&#123;name&#125;echo &quot;end&quot;...end... 执行脚本后无只有end输出，变量没有任何输出，也不报错。 字符串变量bash里面的字符串可以用单引号或双引号，两者有差别 单引号单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的,却不能转义05.sh1234567891011#!/bin/bashname='carvetime'name='carvetime \'hello\''alias='carvetime2'echo 'my name is $&#123;alias&#125;'..../examples/02/code/05.sh: line 4: unexpected EOF while looking for matching `''./examples/02/code/05.sh: line 5: syntax error: unexpected end of file... 双引号双引号里可以有变量,双引号里可以出现转义字符有点类似js的反斜杠06.sh12345678910#!/bin/bashname=&quot;carvetime \&quot;hello\&quot;&quot;echo $&#123;name&#125;alias=&quot;carvetime2&quot;echo &quot;my name is $&#123;alias&#125;&quot;...carvetime &quot;hello&quot;my name is carvetime2... 拼接字符串我们来看下单引号和双引号的字符串拼接12345678910111213141516171819#!/bin/bashsay="hi"name="carvetime"hi1="$&#123;say&#125; "$name" !"hi2="$&#123;say&#125; $&#123;name&#125; !"echo $hi1 $hi2hi3='hi '$name' !'hi4='hi $&#123;name&#125; !'echo $hi3 $hi4...hi carvetime ! hi carvetime !hi carvetime ! hi $&#123;name&#125; !... 字符串操作08.sh123456789101112131415161718192021#!/bin/bash# 获取字符串长度person=&quot;xiaobaitongxue&quot;echo &quot;person 字符串长度是： $&#123;#person&#125;&quot;# 提取子字符串echo &quot;1-3的字符串式是：$&#123;person:1:3&#125;&quot;# 查找字符串#echo `expr index &quot;$person&quot; tongxue`# mac上不支持 expr 语法我们改用start=$&#123;person%%tongxue*&#125;+1echo &quot;起始位置是： $&#123;#start&#125;&quot;...person 字符串长度是： 141-3的字符串式是：iao起始位置是： 9... The expr in Linux is generally GNU expr. Mac OS X uses BSD expr which does not have the index command. You could install/compile GNU expr or use this:echo string1 | sed -n &quot;s/[string2].*//p&quot; | wc -c 数组变量bash不支持二维数组，只支持一维数组123456789101112131415#!/bin/bashnumbers=(1 2 3 4)numbers[3]=5echo $&#123;numbers[0]&#125;echo $&#123;numbers[@]&#125;echo $&#123;#numbers[*]&#125;echo $&#123;#numbers[@]&#125;...11 2 3 544...]]></content>
      <categories>
        <category>基础</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell 02 参数传递]]></title>
    <url>%2F2019%2F06%2F07%2Fbase%2Fshell%2Fshell-03-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[执行脚本的我们是可以传多个参数 终端执行传参1./examples/03/code/01.sh 1 2 3 01.sh123456789101112131415echo "input value0 is $0"echo "input value1 is $1"echo "input value2 is $2"echo "input value3 is $3"echo "number of input is $#"echo "所以参数以字符串显示：$*"...input value0 is ./examples/03/code/01.shinput value1 is 1input value2 is 2input value3 is 3number of input is 3所以参数以字符串显示：1 2 3... 如果参数包含空格应该用单引号或双引号括起来 终端执行传参1./examples/03/code/01.sh '1 a' '2 b' '3 c' 我们再看下输出12345678...input value0 is ./examples/03/code/01.shinput value1 is 1 ainput value2 is 2 binput value3 is 3 cnumber of input is 3所以参数以字符串显示：1 a 2 b 3 c...]]></content>
      <categories>
        <category>基础</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell 04 运算符]]></title>
    <url>%2F2019%2F06%2F07%2Fbase%2Fshell%2Fshell-04-%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[shell除了和其他语言一样支持算数、关系、布尔、字符串运算符之外，还支持文件测试运算符 我们先看下通用的的算数、关系、布尔、字符串运算符 01.sh1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889a=2b=3# 注意`expr 1+1`写法是错误的，需要有空格 sum=`expr $a + $b`echo "sum:$&#123;sum&#125;"# 注意`if [$a == $b]`写法是错误的，需要有空格 if [ $a == $b ]then echo "a 等于 b"fiif [ $a != $b ]then echo "a 不等于 b"fiif [ $a -eq $b ]then echo " a 等于 b"else echo "a 不等于 b"fiif [ $a -ne $b ]then echo "a 不等于 b"else echo " a 等于 b"fi# -eq 等于 equals # -ne 不等于 no equals# -gt 大于 greater than# -lt 小于 less than# -ge 大于等于 greater equals# -le 小于等于 less equalsif [ $a -gt 1 -a $b -gt 1 ]then echo "$a 大于 1 同时 $b 大于 1 "fiif [[ $a -gt 1 &amp;&amp; $b -gt 1 ]]then echo "$a 大于 1 同时 $b 大于 1 "fi# ！非运算 # -o 或运算 or# -a 且 andc='abc'd='abc'e='def'if [ $c = $d ]then echo "$c 等于 $d"fiif [ $d == $d ]then echo "$c 等于 $d"fiif [ $d != $e ]then echo "$c 不等于 $e"fi# test 等同于 [ ]if test $d != $e then echo "$c test方法 判断不等于 $e"fi...sum:5a 不等于 ba 不等于 ba 不等于 b2 大于 1 同时 3 大于 1 2 大于 1 同时 3 大于 1 abc 等于 abcabc 等于 abcabc 不等于 defabc test方法 判断不等于 def... 可以发现shell的运算符和其他语言都基本一样，只是关键字变了一下。接下来我们来看下shell特有的文件测试运算符 02.sh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/bin/bashfile="./examples/04/code/01.sh"emptyFile="./examples/04/code/empty"folder='./examples/04/code'if [ -w $file ]then echo "文件可写"else echo "文件不可写"fiif [ -x $file ]then echo "文件可执行"else echo "文件不可执行"fiif [ -s $emptyFile ]then echo "文件不为空"else echo "文件为空"fiif [ -s $file ]then echo "文件不为空"else echo "文件为空"fiif [ -s $folder ]then echo "是文件夹"else echo "不是文件夹"fi...文件可写文件可执行文件为空文件不为空是文件夹...]]></content>
      <categories>
        <category>基础</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell 05 流程控制]]></title>
    <url>%2F2019%2F06%2F07%2Fbase%2Fshell%2Fshell-05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[shell的流程控制if else、for 循环、do while和大多数编程语言差不多，我们一个个简单写下 if else这里的[]和test是等同的1234567891011121314151617181920212223242526272829#!/bin/bashage1=30age2=40# 判断流程if test $age1 -lt 18then echo "未成年"elif test $age1 -lt 35then echo "中年人"else echo "老年人"fiif [ $age2 -lt 18 ]then echo "未成年"elif [ $age2 -lt 35 ]then echo "中年人"else echo "老年人"fi...中年人老年人... for 循环12345678910111213# 循环流程for val in 1 2 3 4 5do echo "value is $val"done...value is 1value is 2value is 3value is 4value is 5... while语句12345678910111213141516171819202122232425262728293031323334num=1while([ $num -lt 3 ])do echo $num let "num++"doneuntil [ $num -eq 5 ]do echo $num num=`expr $num + 1`done # while : # do# echo "无限循环"# done# while true # do# echo "无限循环"# done# echo '请输入你的年龄'# read age# case $age in# 18) echo '刚好成年'# ;;# 50) echo '老年人'# ;;# *) echo '不清楚的年龄'# ;;# esac case语句123456789101112131415161718192021222324252627# echo '请输入你的年龄'# read age# case $age in# 18) echo '刚好成年'# ;;# 50) echo '老年人'# ;;# *) echo '不清楚的年龄'# ;;# esacwhile :do echo "请猜一个1-5的数字" read numx case $numx in 1|2|3|4) echo "请输入的数字是 $numx" ;; 5) echo "输入有误将退出" continue ;; *) echo "输入有误将退出" break ;; esacdone]]></content>
      <categories>
        <category>基础</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 07 生产环境]]></title>
    <url>%2F2019%2F06%2F05%2Fjs%2Fwebpack%2Fwebpack-07-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[生产环境和开发环境的配置有部分差异的，生产环境追求打包的代码最小化，开发环境追求调试方便，所以需要souce map，live reload等，通常情况下我们会针对不同环境下编写不同的配置，但是两者之间又存在共同的一些配置，在此我们将使用到 webpack-merge 的工具，我们独立写一份common的配置，然后merge到不同的环境中 首先我们先安装下 webpack-merge1npm install --save-dev webpack-merge 分别创建并配置3个文件 webpack.common.js1234567891011121314151617181920const path = require('path')const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; mode: 'development', entry: &#123; index:'./examples/07/code/src/index.js' &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title: 'Product' &#125;) ], output: &#123; filename: '[name].[contenthash].bundle.js', path: path.resolve(__dirname, 'examples/07/code/dist') &#125;&#125; webpack.dev.js12345678910const merge = require('webpack-merge')const common = require('./webpack.common.js')module.exports = merge(common,&#123; mode: 'development', devtool: 'inline-source-map', devServer: &#123; contentBase: './examples/07/code/dist/' &#125;&#125;) webpack.prod.js123456const merge = require('webpack-merge')const common = require('./webpack.common.js')module.exports = merge(common,&#123; mode: 'production'&#125;) 然后配置下package.json（这里只展示配置的部分代码）123456&#123; "scripts": &#123; "start": "webpack-dev-server --open --config webpack.dev.js", "build": "webpack --config webpack.prod.js" &#125;&#125; 最后通过通过命令行执行不同环境的脚本12345# 开发环境npm run start# 生产环境npm run build github代码]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 06 tree shaking]]></title>
    <url>%2F2019%2F06%2F05%2Fjs%2Fwebpack%2Fwebpack-06-tree-shaking%2F</url>
    <content type="text"><![CDATA[Tree shaking 是webpack是借鉴于rollup的无用代码移除的概念，只有在product环境下时候webpack才会使用tree shaking机制，以此达到最大的优化缩减代码体积。 我们首先创建一个test.js文件，里面包含两个方法 1234567export function test1()&#123; console.log("test1")&#125;export function test2()&#123; console.log("test2")&#125; 然后在index.js里面调用test.js的其中一个test1方法123import &#123;test1&#125; from './test'test1() 配置下简单webpack.config.js文件123456789101112131415161718192021const path = require('path')const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; mode: "development", entry: &#123; index:'./examples/06/code/src/index.js' &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title: 'tree shaking' &#125;) ], output: &#123; filename: '[name].[contenthash].bundle.js', path: path.resolve(__dirname, 'examples/06/code/dist') &#125;&#125; 然后run一下看看打包结果1npm run build 查看下dist/index.哈希值.bundle文件中代码 12345678// 精简后的代码eval(&quot;__webpack_require__.d(__webpack_exports__, \&quot;test1\&quot;, function() &#123; return test1; &#125;);__webpack_require__.d(__webpack_exports__, \&quot;test2\&quot;, function() &#123; return test2; &#125;);function test1()&#123;\n console.log(\&quot;test1\&quot;)\n&#125;function test2()&#123;\n console.log(\&quot;test2\&quot;)\n&#125;//# sourceURL=webpack:///./examples/06/code/src/test.js?&quot;); 我们发现这里面只有test1和test2方法，test2方法我们并没有实际使用，但是还是打包进来了 接下来我们修改下webpack.config.js的打包环境123module.exports = &#123; mode: &quot;production&quot;,&#125; 再run一下再查看下dist/index.哈希值.bundle文件中代码 12// 精简后的部分代码return r.d(t,&quot;a&quot;,t),t&#125;,r.o=function(e,t)&#123;return Object.prototype.hasOwnProperty.call(e,t)&#125;,r.p=&quot;&quot;,r(r.s=0)&#125;([function(e,t,r)&#123;&quot;use strict&quot;;r.r(t),console.log(&quot;test1&quot;)&#125;]); 我们发现这里面只有test1方法，并没有发现test2方法，说明在生产环境下无用代码没有被打包进来。 看上去只要我们直接生产环境打包就tree shaking就会自动删除无用代码，但tree shaking还是存在局限和不足，比如在某些情况下不能做到完全移除无用代码的情况，以及它建立在静态语法分析的基础上，需要确保代码没有使用或编译成CommonJS模块，这个留到后期再进一步解析。 github代码]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 05 缓存]]></title>
    <url>%2F2019%2F06%2F04%2Fjs%2Fwebpack%2Fwebpack-05-%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[浏览器去服务器下载资源是比较耗时操作，为此浏览器都有个缓存机制，根据文件路径名称否变化去决定是否使用本地缓存，从而减少不必要的远端请求，那么此时就需要我们每次在deploy的服务器的时候，需要有个文件命名输出策略。 接下来我们一步步看下，我们的缓存输出策略的衍变 通过配置 output 输出文件名webpack.config.js12345678910111213141516171819const path = require('path')const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; index:'./examples/05/code/src/index.js' &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title: 'Caching' &#125;), ], output: &#123; filename: '[name].[contenthash].bundle.js', path: path.resolve(__dirname, 'examples/05/code/dist') &#125;&#125; 运行下脚本12345678npm run build...Built at: 06/04/2019 11:40:10 AM Asset Size Chunks Chunk Namesindex.3d1cf78a2f957c55fdd2.bundle.js 70.4 KiB 0 [emitted] index index.html 205 bytes [emitted] Entrypoint index = index.3d1cf78a2f957c55fdd2.bundle.js... 我们稍微修改了src/index.js文件的内容,然后再run一下1234567...Built at: 06/04/2019 11:54:39 AM Asset Size Chunks Chunk Namesindex.f9767fa8b88847641fa6.bundle.js 70.4 KiB 0 [emitted] index index.html 205 bytes [emitted] Entrypoint index = index.f9767fa8b88847641fa6.bundle.js... bundle的哈希值是有变化，因为bundle包含了引用的vender文件，所以相当于每次改动bundle一点代码，就会重新引用一遍vender库文件，这样势必导致浏览器延长加载时长。 提取模板为了进一步改善优化webpack的缓存方案，提取模块会将共用的vender模块代码摘取出来，做到和业务代码的有效分离，一遍修改业务代码时，不影响vender的代码的缓存，我们稍微再修改下配置 webpack.config.js123456789101112131415161718192021222324252627282930313233const path = require('path')const webpack = require('webpack');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; index:'./examples/05/code/src/index.js', print: './examples/05/code/src/print.js' &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title: 'Caching' &#125;), ], output: &#123; filename: '[name].[contenthash].bundle.js', path: path.resolve(__dirname, 'examples/05/code/dist') &#125;, optimization:&#123; runtimeChunk: 'single', splitChunks:&#123; cacheGroups:&#123; vendor:&#123; test: /[\\/]node_modules[\\/]/, name: 'vendors', chunks: 'all' &#125; &#125; &#125; &#125;&#125; 这时候我们在run一次12345678910npm run build...Built at: 06/04/2019 3:08:43 PM Asset Size Chunks Chunk Names index.9fef7a7c6b56b8c1f5ee.bundle.js 230 bytes 1 [emitted] index index.html 458 bytes [emitted] print.718d4b2cf1f46b8669a4.bundle.js 181 bytes 2 [emitted] printruntime.fcfdsfa7dfds7wqefed.bundle.js 1.42 KiB 0 [emitted] runtimevendors.4c03bd33715510606f13.bundle.js 69.4 KiB 3 [emitted] vendors... 显然多出来了runtime和vendors的bundle代码，我再稍微看下打包出来的index文件里面也已经不包含vender的代码拉，这时候我们修改index里面的业务代码应该只会修改index的哈希值，我们稍微修改下element.innerHTML = _.join([&#39;缓存&#39;,&#39;机制8&#39;])来验证下 12345678910run run build ...Built at: 06/04/2019 3:14:39 PM Asset Size Chunks Chunk Names index.ff90502fc5bb7df67079.bundle.js 230 bytes 1 [emitted] index index.html 458 bytes [emitted] print.718d4b2cf1f46b8669a4.bundle.js 181 bytes 2 [emitted] printruntime.fcfdsfa7dfds7wqefed.bundle.js 1.42 KiB 0 [emitted] runtimevendors.4c03bd33715510606f13.bundle.js 69.4 KiB 3 [emitted] vendors... 对比发现确实只有index.ff90502fc5bb7df67079.bundle.js文件哈希值变啦。 到这里的话应该缓存的衍化过程应该差不多了，但是还存在一种引入模块的情况需要考虑，我们来看下比如在index.js里面新引入一个print.js文件 src/print.js123export default function print(text)&#123; console.log(text)&#125; src/index.js 1234567import _ from 'lodash'import print from './print'const element = document.createElement('div')element.innerHTML = _.join(['缓存','机制8'])print("hello")document.body.appendChild(element) run一次看下信息12345678910npm run build...Built at: 06/04/2019 3:20:01 PM Asset Size Chunks Chunk Names index.405aec4d016a32b6164a.bundle.js 377 bytes 1, 2 [emitted] index index.html 458 bytes [emitted] print.3993c439110c8a92b7cb.bundle.js 179 bytes 2 [emitted] printruntime.fc9b88b3a7557471c20d.bundle.js 1.42 KiB 0 [emitted] runtimevendors.9e03bed8e5b636aca9c6.bundle.js 69.4 KiB 3 [emitted] vendors... 对比发现index、vender、runtime文件都改变了，我们只是引入了一个新的模块文件，vender是没有任何内容修改的，所以vender的哈希值改变，肯定不是我们想要的，此时我们将环境配置为development时，webpack会给我内部做优化处理，不会修改vender的哈希值，但是生产环境还是需要我们进一步配置 webpack.config.js1234567891011121314151617181920212223242526272829303132333435const path = require('path')const webpack = require('webpack');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; // mode: 'development', entry: &#123; index:'./examples/05/code/src/index.js', print: './examples/05/code/src/print.js' &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title: 'Caching' &#125;), new webpack.HashedModuleIdsPlugin() ], output: &#123; filename: '[name].[contenthash].bundle.js', path: path.resolve(__dirname, 'examples/05/code/dist') &#125;, optimization:&#123; runtimeChunk: 'single', splitChunks:&#123; cacheGroups:&#123; vendor:&#123; test: /[\\/]node_modules[\\/]/, name: 'vendors', chunks: 'all' &#125; &#125; &#125; &#125;&#125; 新增的new webpack.HashedModuleIdsPlugin()插件对生产环境的模块的修改做优化处理，此时我们再run一次发现，vender模块还是保持原样。 github代码]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 04 代码分离]]></title>
    <url>%2F2019%2F06%2F03%2Fjs%2Fwebpack%2Fwebpack-04-%E4%BB%A3%E7%A0%81%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[实际开发中我们会生成多个文件或者多个文件引用某个共用组件，打包的时候不可能全部打包到一个bundle里面，webpack通常有三种方式 入口配置这是一种简单直观的代码分离方式，我们来看下以下配置 webpack.config.js1234567891011121314151617181920const path = require('path')const webpack = require('webpack')const HTMLWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; mode: 'development', entry: &#123; index: './examples/04/code/src/index.js', another: './examples/04/code/src/another-module.js', &#125;, plugins: [ new HTMLWebpackPlugin(&#123; title: 'Code Splitting' &#125;), ], output: &#123; filename: '[name]-bundle.js', path: path.resolve(__dirname, 'examples/04/code/dist') &#125;&#125; src/another-module.js123import _ from 'lodash'console.log(_join(['load','another','module'])) src/index.js12345import _ from 'lodash'const div = document.createElement('div')div.innerText = _join(['load','index'])document.body.appendChild(div) 然后我们在终端run打包看下123456npm run build#生成的文件是#Built at: 06/03/2019 11:29:02 AM# Asset Size Chunks Chunk Names#another-bundle.js 551 KiB another [emitted] another#index-bundle.js 551 KiB index [emitted] index 我们会发现文件size还是比较大，然后查看里面代码，两个文件都都copy了一份lodash的代码，所以导致文件体积过大。 防止重复为了让防止代码重复copy和不够灵活的问题，webpack内置了optimization.splitChunks 方法去提取分离重复的代码,我们来看下以下配置 webpack.config.js12345678910111213141516171819202122232425const path = require('path')const webpack = require('webpack')const HTMLWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; mode: 'development', entry: &#123; index: './examples/04/code/src/index.js', another: './examples/04/code/src/another-module.js', &#125;, plugins: [ new HTMLWebpackPlugin(&#123; title: 'Code Splitting' &#125;), ], optimization: &#123; splitChunks: &#123; chunks: 'all' &#125; &#125;, output: &#123; filename: '[name]-bundle.js', path: path.resolve(__dirname, 'examples/04/code/dist') &#125;&#125; 此时再重新build一次12345678npm run build#生成的文件是# Built at: 06/03/2019 11:36:26 AM#A sset Size Chunks Chunk Names# another-bundle.js 6.98 KiB another [emitted] another# index-bundle.js 6.99 KiB index [emitted] index# index.html 333 bytes [emitted] # vendors~another~index-bundle.js 547 KiB vendors~another~index [emitted] vendors~another~index 通过打包信息以及生产的文件代码我们可以看出，内置的optimization.splitChunks方法将lodash分离成一份共用代码，这样代码就显得灵活和不累赘重复啦，另外针对其他类型的代码分离，可使用mini-css-extract-plugin bundle-loader promise-loader 插件对css 和 bundle 进行防重分离，在此不一一示例。 动态导入动态导入的方法与防重复的方法有些类似，也是会对共用代码进行提取分离，不同之处是，动态导入方法是按需懒加载加载，只有在动态运行时才加载依赖相关代码 webpack.config.js123456789101112const path = require('path')module.exports = &#123; mode: 'development', entry: &#123;inde:'./examples/04/code/src/index.js'&#125;, output: &#123; filename: '[name].bundle.js', chunkFilename: '[name].bundle.js', path: path.resolve(__dirname, 'examples/04/code/dist') &#125;&#125; src/index.js1234567891011function getComponent()&#123; return import('lodash').then((&#123;default: _&#125;) =&gt;&#123; const element = document.createElement('div') element.innerHTML = _.join(['Hello','Webpack']) return element &#125;).catch(error =&gt; 'load lodash error')&#125;getComponent().then(component =&gt; &#123; document.body.appendChild(component)&#125;) 重新打包一次12345npm run build# Built at: 06/03/2019 6:19:34 PM# Asset Size Chunks Chunk Names# 0.bundle.js 547 KiB 0 [emitted] # inde.bundle.js 8.92 KiB inde [emitted] inde 查看下生成的dist/index.bundle.js文件1eval("// import _ from 'lodash' 省略其中中间代码") 可见是在执行getComponent方法时候动态调用的import _ from ‘lodash’方法 此外，我们还可以使用 async functions对此方法进行简化,如下 12345678910async function getComponent()&#123; const &#123;default: _&#125; = await import('lodash') const element = document.createElement('div') element.innerHTML = _.join(['Hello','Webpack']) return element&#125;getComponent().then(component =&gt; &#123; document.body.appendChild(component)&#125;) github代码]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 03 开发环境]]></title>
    <url>%2F2019%2F06%2F03%2Fjs%2Fwebpack%2Fwebpack-03-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[webpack支持三种自定编译方式 观察模式这是webpack自带的自动编译模式，只需在package.json中配置 123"scripts": &#123; "watch": "webpack --watch"&#125; 然后终端输入命令行开启观察者模式1npm run watch 此时只要文件改动，代码将会重新编译，不过需要手动刷新浏览器。 webpack-dev-server首先需要先npm安装下1npm install --save-dev webpack-dev-server 然后配置webpack.config.js，告诉本地开发服务器在哪查找文件123devServer: &#123; contentBase: './examples/03/code/dist/'&#125; 接着我们在package.json里面配置下启动的script脚本123"scripts": &#123; "devserver": "webpack-dev-server --open"&#125; 最后在终端运行1npm run devserver 此时会开启一个浏览器页面，修改了index.js文件后也会同步更新 本地服务器会将编译后的文件存在服务器内存中，不会写入任何编译后的文件到本地磁盘，如果想看到编译后的文件，可以配置一个publicPath，并在该目录下查看。 webpack-dev-middlewarewebpack-dev-middleware，可以结合express server进行更多的自定义配置 首先我们安装下express 和 webpack-dev-middleware1npm install --save-dev express webpack-dev-middleware 接着配置webpack.config.js12345678910111213141516171819const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; mode: 'development', entry: './examples/03/code/src/index.js', plugins: [ new HtmlWebpackPlugin(&#123; title: 'Output Management' &#125;) ], output: &#123; filename: 'bundle.js', path: path.resolve(__dirname,'/examples/03/code/dist'), publicPath: '/' &#125;&#125; 然后创建一个server.js文件123456789101112131415const express = require('express')const webpack = require('webpack')const webpackDevMiddleWare = require('webpack-dev-middleware')const app = express()const config = require('../../../webpack.config.js')const compiler = webpack(config)app.use(webpackDevMiddleWare(compiler,&#123; publicPath: config.output.publicPath&#125;))app.listen(3000,function()&#123; console.log("app listening on port 3000")&#125;) 最后终端执行1node ./examples/03/code/server.js github代码]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 02 资源管理]]></title>
    <url>%2F2019%2F06%2F03%2Fjs%2Fwebpack%2Fwebpack-02-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[webpack除了支持javascript外，还支持通过loader处理其他类型文件 加载CSS先安装并添加 style-loader 和 css-loader1npm install --save-dev style-loader css-loader 然后配置webpack.config.js,通过正则来匹配需要处理的css文件1234567891011121314151617181920const path = require('path')module.exports = &#123; entry: './examples/02/code/src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'examples/02/code/dist') &#125;, module: &#123; rules:[ &#123; test: /style.css$/, use: [ 'style-loader', 'css-loader' ] &#125; ] &#125;&#125; 加载图片先安装并添加 file-loader1npm install --save-dev file-loader 然后配置webpack.config.js,通过正则来匹配需要处理的文件12345678910111213141516171819const path = require('path')module.exports = &#123; entry: './examples/02/code/src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'examples/02/code/dist') &#125;, module: &#123; rules:[ &#123; test: /png$/, use: [ 'file-loader' ] &#125; ] &#125;&#125; 此外还有 csv-loader xml-loader 分别支持导入CSV、TSV 和 XML等资源文件，再此不一一例举。 github代码]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 01 起步]]></title>
    <url>%2F2019%2F06%2F03%2Fjs%2Fwebpack%2Fwebpack-01-%E8%B5%B7%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[先初步使用下webpack 安装终端创建一个工程文件，用npm配置webpack1234mkdir demonpm install -ynpm install webpack --save-devnpm install webpack-cli --save-dev 工程文件我们来对比下传统和webpack的文件引用方式 传统方式dist/index.html123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;Getting Started&lt;/title&gt; &lt;script src="https://unpkg.com/lodash@4.16.6"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="./src/index.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; src/index.js1234567function component()&#123; const element = document.createElement('div') element.innerHTML = _.join(['Hello', 'webpack']) return element;&#125;document.body.append(component()) 这时候直接浏览器打开 dist/index.html 文件我们会正常显示div的标签，但是这样方式很多明显不足 不能立即体现，index.js的文件隐式依赖 本页面script脚本引入 如果依赖下载失败或出错就会导致整个程序无法运行 如果没有使用，就造成不必要的下载 webpack的引用方式基于传统方式的各种不足，我们可以对比衍变出来的webpack的方式的优势12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;Getting Started&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 使用webpack根据./src/index.js文件打包压缩后的文件成bounde.js，并放在dist文件夹下和index.html同级，因此html直接引用打包压缩后的bounde.js文件 --&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 然后我们通过命令行执行1./node_modules/.bin/webpack --config webpack.config.js 或通过npx直接查找执行1npx webpack --config webpack.config.js 或者在package.json里面配置npx webpack –config webpack.config.js1npm run build 最后通过浏览器打开index.html文件就也可以看到index.js创建出来的div标签，可见webpack达到了和上面一样的效果，传统方式的不足也解决，当然webpack的优点不止于此，可通过后面的章节一起了解到更多。 github代码]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新概念英语第一册 05 Nice to meet you]]></title>
    <url>%2F2019%2F05%2F30%2Fenglish%2Fnewconceptenglish%2Flession05%2F</url>
    <content type="text"><![CDATA[Is Chang-Woo chinese? ContentGood morning. Good morning, Mr. blake. This is Miss Sophie Dupont. Sophie is an new student. She is French Nice to meet you. Sophie, this is Hans. He is German. Nice to meet you. And this is NaoKo. She is Japanese. Nice to meet you. And this is Chang-woo. He is Korean. Nice to meet you. This is Luming. Nice to meet you. He is Chinese. Nice to meet you. This is Xiaohui. She’s Chinese, too. Nice to meet you. VocabularyGerman Japanese Korean Italian Swedish American Explanation冠词冠词数量上标识一个或这个用来修饰名词 不定冠词a，an是不定冠词，可数名词前必须要用不定冠词，名词是辅音开头用a，名词是元音开头用an 定冠词 特指名词，表示说话或听话人已知的人或物时用the，There is an apple on the floor. The apple is mine. 专有的特属名词或独一无二的事物用the，The Great Wall, the sun 乐器用the，She paly the piano 表示人体部位用the，He pat me on the back 表示一家人用the，The Smith live in the apartment above ours]]></content>
      <categories>
        <category>english</category>
        <category>新概念英语第一册</category>
      </categories>
      <tags>
        <tag>新概念英语第一册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新概念英语第一册 03 Sorry, sir]]></title>
    <url>%2F2019%2F05%2F30%2Fenglish%2Fnewconceptenglish%2Flession03%2F</url>
    <content type="text"><![CDATA[Does the man get his umbrella back? ContentMy coat and my umbrella please. Here is my ticket. Thank you, sir. Number five. Here is your umbrella and caot. This isn’t my umbrella. Sorry sir. Is this your umbrella No, it isn’t. is this it? yes, it is. Thank you very much. Vocabularyumbrellla 雨伞 cloakroom 衣帽间；寄存处 Explanation祈使句Help your self 请自己动手 Keep off the grass 远离草地/请勿践踏草地 倒装句Here is my ticket 我的票在这里]]></content>
      <categories>
        <category>english</category>
        <category>新概念英语第一册</category>
      </categories>
      <tags>
        <tag>新概念英语第一册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新概念英语第一册 01 Excuse me]]></title>
    <url>%2F2019%2F05%2F30%2Fenglish%2Fnewconceptenglish%2Flession01%2F</url>
    <content type="text"><![CDATA[Whose handbag is it? ContentExcuse me ? Yes? is this your handbag? pardon ? is this your handbag? yes it is. thank you very much! Vocabularyticket Explanation陈述句This is your watch. 疑问句Is this your watch？]]></content>
      <categories>
        <category>english</category>
        <category>新概念英语第一册</category>
      </categories>
      <tags>
        <tag>新概念英语第一册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC对象内存结构]]></title>
    <url>%2F2019%2F05%2F29%2Fios%2F%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%2FOC%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[OC对象底层其实是由c/c++结构体，然后转成汇编最后到机器语言。 isa指针oc代码中的一个普通对象1NSObject *objc = [[NSObject alloc] init]; 我们在终端用clang编译成c/c++代码1clang -rewrite-objc main.m -o main.cpp 实际生成的c/c++代码个机构体，里面包含了一个isa指针123struct NSObject_IMPL &#123; Class isa;&#125;; Class其实又是objc_class结构体指针1typedef struct objc_class *Class; 那么一个指针的大小是多少呢，一般32位CPU是4字节，64位CPU是8字节。 一般我们所说的32或64位处理器，就是指该处理器的寻址位数，不同位数的CPU对于对应的是不同的内存寻址的能力，一个字节对应8位二进制，因此32位CPU=32/8,64位CPU=64/8 对象的内存大小我们先创建一个普通的Student对象123456@interface Student : NSObject&#123; @public int _no; int _age;&#125;@end 然后通过clang编译生成c++代码1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp 可以发现最终编译成的结构体如下12345struct Student_IMPL &#123; struct NSObject_IMPL NSObject_IVARS; // 8Byte int _no; // 4Byte int _age; // 4Byte&#125;; OC的Student对象编译成c++后，变成了Student_IMPL结构体，并包含一个NSObject_IMPL结构体及两个结构体成员，其中NSObject_IMPL是一个包含isa指针的结构体，我们统一以64位处理器为例，那么所占的内存空间就是8字节，另外两个成员分别是int占4字节。根据内存对齐原则，Student对象共占16字节大小。 对象的内存结构通过Xocde查看内存结构我们通过xocde打断点进一步查看Student对象的内存地址可以得到，在对象断点处右键Debug Workflow -&gt; viewMemory memory of “*stu”来查看内存地址123Student *stu = [[Student alloc] init]; // C9 13 00 00 01 80 1D 00 00 00 00 00 00 00 00 00stu-&gt;_no = 4; // C9 13 00 00 01 80 1D 00 04 00 00 00 00 00 00 00stu-&gt;_age = 5; // C9 13 00 00 01 80 1D 00 04 00 00 00 05 00 00 00 当stu对象刚创建出来时候，前8个字节C913000001801D00代表的是就是isa指针的地址，后8个字节的内存空间是预留出来了，都是0000000000000000，然后断点往下走，当给成员变量_no和_age赋值的时候变成了04000000 05000000 这里涉及到大小端排列模式的问题 大端模式是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。 小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低 由此可见ios是采用小端模式 通过LLDB指令查看并修改变量的值Xcode自带LLDB调试指令，下面我们通过LLDB调试指令来查看并动态修改某个属性内存的值12memory read/4xw# 0x100505410: 0x73c6ae80 0x00007fff 0x00000000 0x00000000 LLDB查看内存地址指令格式：memory read/数量 _ 格式 _ 字节数 内存地址，数量代表从内存地址起始位置开始打印多少，格式代表是以多少进制显示，字节数代表按照多少字节读取 目前属性还没有复制我们继续断点往下走，再执行一次以十进制的方式查看123456memory read/4dwmemory read/4dw # 0x1005053f0: 5065# 0x1005053f4: 1933313# 0x1005053f8: 4# 0x1005053fc: 5 接下来我们来动态修改下某个属性的值12345678memory write 0x1005053f8 2memory read/4dw stu# 0x1005053f0: 5065# 0x1005053f4: 1933313# 0x1005053f8: 2# 0x1005053fc: 5po stu-&gt;_no# 2 以上说的都是实际利用的内存空间大小，但是实际上ios对象分配最小空间是16字节（可查看通过runtime源码的instanceSize方法），所以当我们创建一个NSObject对象时，实际就是一个isa指针，在64位CUP利用了8个字节，但分配的是16个字节。另外8个字节可能是空的。 github代码]]></content>
      <categories>
        <category>ios</category>
        <category>底层源码</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git版本控制 (一)]]></title>
    <url>%2F2019%2F01%2F11%2Fbase%2Fgit%2Fgit%2F</url>
    <content type="text"><![CDATA[初始化仓库1$ git init 从现有仓库克隆123$ git clone git://github.com/schacon/xxxxx.git// 克隆的时候自定义文件夹$ git clone git://github.com/schacon/grit.git mygrit 检查当前文件状态1$ git status 跟踪新文件1$ git add git add 会递归所有文件，同时还可以把冲突文件标记为已解决 忽略某些文件gitignore规范 所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略 可以使用标准的 glob 模式匹配 匹配模式最后跟反斜杠（/）说明要忽略的是目录 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 For example12345678910111213# 此为注释 – 将被 Git 忽略# 忽略所有 .a 结尾的文件*.a# 但 lib.a 除外!lib.a# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO/TODO# 忽略 build/ 目录下的所有文件build/# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txtdoc/*.txt# 忽略 doc/ 目录下所有扩展名为 txt 的文件doc/**/*.txt 查看已暂存和未暂存的更新1git diff 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容 12git diff --cachedgit diff -- staged // 1.6.1 version lat 次命令是看已经暂存起来的文件和上次提交时的快照之间的差异 提交更新123git commit //会默用vim打开生成一个提交信息git commit -m &quot;test&quot; //快捷方式直接输入提交信息` 跳过使用暂存区域尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 git commit 加上 -a 选项1git commit -a -m &apos;test&apos; 此命令相当于执行了git add 再执行 git commit -m “test” 移除文件123rm test.html //移除文件git rm text.html //staged区移除git rm -f text.html //如果之前对删除文件有过修改并在staged中可能需要强制删除命令 另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆 .a 编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 .gitignore 文件中补上，用 –cached 选项即可1git rm --cached readme.txt 后面可以列出文件或者目录的名字，也可以使用 glob 模式。比方说：1git rm log/\*.log 注意到星号 * 之前的反斜杠 \，因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开（译注：实际上不加反斜杠也可以运行，只不过按照 shell 扩展的话，仅仅删除指定目录下的文件而不会递归匹配。上面的例子本来就指定了目录，所以效果等同，但下面的例子就会用递归方式匹配，所以必须加反斜杠。）。此命令删除所有 log/ 目录下扩展名为 .log 的文件。类似的比如：1git rm \*~ 会递归删除当前目录及其子目录中所有 ~ 结尾的文件 移动文件1git mv file_from file_to 运行 git mv 就相当于运行了下面三条命令123$ mv README.txt README$ git rm README.txt$ git add README 如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式都一样。当然，直接用 git mv 轻便得多，不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名 查看提交历史12345678910111213141516171819202122git log 所有提交git log -1 // 最近一次提交git log -p // 会展示每次提交的差异git log -p -2 最近两次提交并展示diffgit log -U1 --word-diff // 这里的对比显示在行间。新增加的单词被 &#123;+ +&#125; 括起来，被删除的单词被 [- -] 括起来git log --stat // 显示简要的增改行数统计git log --pretty=oneline //一行显示git log --pretty=short // 精简模式git log --pretty=format:&quot;%h - %an, %ar : %s&quot; // 格式化git log --pretty=format:&quot;%h %s&quot; --graph // 格式并图形化显示-p 按补丁格式显示每个更新之间的差异--word-diff 按 word diff 格式显示差异--stat 显示每次更新的文件修改统计信息。--shortstat 只显示 --stat 中最后的行数修改添加移除统计--name-only 仅在提交信息后显示已修改的文件清单。--name-status 显示新增、修改、删除的文件清单--abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。--relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。--graph 显示 ASCII 图形表示的分支合并历史--pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）--oneline --pretty=oneline --abbrev-commit 的简化用法 12345678910111213git log --since=2.weeks //近两周内的提交git log -Sfunction_name //找出添加或移除了某一个特定函数的引用的提交git log --pretty=&quot;%h - %s&quot; --author=gitster --since=&quot;2008-10-01&quot; --before=&quot;2008-11-01&quot; --no-merges -- t //2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件-(n) 仅显示最近的 n 条提交 --since, --after 仅显示指定时间之后的提交 --until, --before 仅显示指定时间之前的提交--author 仅显示指定作者相关的提交--committer 仅显示指定提交者相关的提交--grep 仅显示含指定关键字的提交-S 仅显示添加或移除了某个关键字的提交 撤消操作12345678910111213141516git commit --amend //修改上一条的提交信息$ git commit -m &apos;initial commit&apos;$ git add forgotten_file$ git commit --amend// 修改上一条并提交新的信息成一个提交git checkout . git checkout 文件名 //修改了文件没有add操作时用checkoutgit reset . git reset 文件名// 修改并add之后 需要用resetgit config --global core.quotepath false//git status中文文件名编码问题解决 远程仓库的使用1234567891011121314151617181920212223242526272829303132333435363738git remote //列出每个远程库的简短名字git remote --verbose // 更详细点会包含远程仓库地址git remote add [shortname] [url] // 添加一个新的远程仓库，可以指定一个简单的名字git fetch [shortname] // 抓取远程仓库的所有信息并下载数据到本地此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支有一点很重要，需要记住，fetch命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并git clone [url] 此命令本质上就是自动创建了本地的 master分支用于跟踪远程仓库中的 master分支（假设远程仓库确实有 master 分支）所以一般我们运行 git pull，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支//推送数据到远程仓库git push [remote-name] [branch-name]git push origin master//查看远程仓库信息git remote show [remote-name]git remote show origin//远程仓库的删除和重命名git remote rename [old-name] [new-name]git remote rename pb paul// 移除远程仓库git remote rmgit remote rm paul 打标签123456789101112131415161718192021222324252627282930313233343536373839404142//列显已有的标签git tag//用特定的搜索模式列出符合条件的标签git tag -l &apos;v1.4.2.*&apos;//新建含附注的标签git tag -a v1.4 -m &apos;my version 1.4&apos; //-a 代表 annotated -m 代表说明信息git show v.14 // 查看//签署标签git tag -s v1.5 -m &apos;my signed 1.5 tag&apos;git show v1.5 // 查看//轻量级标签git tag v1.6-lwgit show v1.6 // 查看的到的信息比较简单//验证标签git tag -v [tag-name]git tag -v v1.4.2.1（译注：取 verify 的首字母）的方式验证已经签署的标签。此命令会调用GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证//后期加注标签可以在后期对早先的某次提交加注标签只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可git tag -a v1.2 9fceb02//分享标签git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 git push origin [tagname] 即可git push origin [tagname]git push origin v1.5git push origin --tags // 一次推送所有本地新增的标签上去 技巧和窍门自动补全 如果你用的是 Bash shell，可以试试看 Git 提供的自动补全脚本。下载 Git 的源代码，进入 contrib/completion 目录，会看到一个 git-completion.bash 文件。将此文件复制到你自己的用户主目录中（译注：按照下面的示例，还应改名加上点：cp git-completion.bash ~/.git-completion.bash），并把下面一行内容添加到你的 .bashrc 文件中：1source ~/.git-completion.bash 也可以为系统上所有用户都设置默认使用此脚本。Mac 上将此脚本复制到 /opt/local/etc/bash_completion.d 目录中，Linux 上则复制到 /etc/bash_completion.d/ 目录中。这两处目录中的脚本，都会在 Bash 启动时自动加载。 如果在 Windows 上安装了 msysGit，默认使用的 Git Bash 就已经配好了这个自动补全脚本，可以直接使用。 在输入 Git 命令的时候可以敲两次跳格键（Tab），就会看到列出所有匹配的可用命令建议：12$ git co&lt;tab&gt;&lt;tab&gt;commit config Git 命令别名1234$ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status 可以看出，实际上 Git 只是简单地在命令中替换了你设置的别名。不过有时候我们希望运行某个外部命令，而非 Git 的子命令，这个好办，只需要在命令前加上 ! 就行。如果你自己写了些处理 Git 仓库信息的脚本的话，就可以用这种技术包装起来。作为演示，我们可以设置用 git visual 启动 gitk：1$ git config --global alias.visual &apos;!gitk&apos; git分支Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针 Git 是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为 HEAD 的特别指针，这个指针指向分支 冲突解决123456789修改完冲突文件后执行git add . //保存快照git commit // 完成合并提交git branch //所有分支的清单git branch -v //查看各个分支最后一个提交对象的信息git branch --merged //查看哪些分支已被并入当前分支git branch --no-merged //查看尚未合并的工作git branch -d [branch-name] //可以删除已合并的分支git branch -D [branch-name] //强制删除未合并的分支 远程分支一次 Git 克隆会建立你自己的本地分支 master 和远程分支 origin/master，并且将它们都指向 origin 上的 master 分支如果你在本地 master 分支做了些改动，与此同时，其他人向 git.ourcompany.com推送了他们的更新，那么服务器上的 master 分支就会向前推进，而与此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 origin/master 指针仍然保持原位不会移动 可以运行 git fetch origin 来同步远程服务器上的数据到本地。该命令首先找到 origin 是哪个服务器（本例为 git.ourcompany.com），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 origin/master 的指针移到它最新的位置上（见图 3-24） 现在你可以用 git fetch teamone 来获取小组服务器上你还没有的数据了 推送本地分支 可以运行 git push (远程仓库名) (分支名)123456789git push origin serverfixor git push origin serverfix:serverfixorgit push origin serverfix:awesomebranch//本地分支推送到某个命名不同的远程分支//这里其实走了一点捷径。Git 自动把 serverfix 分支名扩展为 refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”//当你的协作者再次从服务器上获取数据时执行git fetch origin 值得注意的是，在 fetch 操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支。换句话说，在本例中，你不会有一个新的 serverfix 分支，有的只是一个你无法移动的 origin/serverfix 指针 如果要把该远程分支的内容合并到当前分支，可以运行 git merge origin/serverfix。如果想要一份自己的 serverfix 来开发，可以在远程分支的基础上分化出一个新的分支来123456789$ git checkout -b serverfix origin/serverfixor$ git checkout serverfix如果你有 1.6.2 以上版本的 Git，还可以用 --track 选项简化$ git checkout --track origin/serverfix要为本地分支设定不同于远程分支的名字，只需在第一个版本的命令里换个名字git checkout -b sf origin/serverfix 删除远程分支 记住我们不久前见过的 git push [远程名] [本地分支]:[远程分支] 语法12$ git push origin :serverfix//那就等于是在说“在这里提取空白然后把它变成[远程分支]”]]></content>
      <categories>
        <category>基础</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式 (一)]]></title>
    <url>%2F2019%2F01%2F11%2Fbase%2Fregular%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简单文本检索123/123/.test(1234) true/123/.test(0123) true/123/.test(01223) false 上述正则表示存在匹配的匹配的连续字母或数字 起始和结束位置检索123/^cat/.test(&quot;cateee&quot;) //true/^cat/.test(&quot;acateee&quot;) //flase/cat$/.test(&quot;acat&quot;) //true 上述正则表示存在匹配的匹配的连续字母或数字并以其开头或以其结尾 匹配若干字符12/gr[ae]y/.test(&quot;grey&quot;) //true/gr[ae]y/.test(&quot;gray&quot;) //true []内表示字母或数字中其中一个就满足，类似或的意思12345/H[1-9]/.test(&quot;H1&quot;) //true/H[1-9]/.test(&quot;H2&quot;) //true/H[1-9]/.test(&quot;H0&quot;) //false/H[a-z]/.test(&quot;Hb&quot;) //true/H[a-z]/.test(&quot;H1&quot;) //false [-]连字符表示一个范围满足即可123/[0-9a-fA-F]/.test(&quot;A&quot;) //true/[0-9a-fA-F]/.test(&quot;.&quot;) //false/[0-9a-fA-F_.?!]/.test(&quot;?&quot;) //true 上述表达式是连字符和各种字符的组合 注意:只有在字符组内部且非开头位置连字符才是元字符，否则就是匹配普通字符 排除型字符组12/[^1-6]/.test(9) //true /[^1-6]/.test(5) //false ^一般情况下是代表起始位置，但是在字符组内部且紧接在字符组第一个方括号后，就代表一个排除型的元字符 匹配任意字符123/2018.12.12/.test(&quot;2018-12-12&quot;) //true/2018.12.12/.test(&quot;2018:12:12&quot;) //true/2018.12.12/.test(&quot;2018@12@12&quot;) //true .代表可以匹配任意字符 表达式组合12345678/Bob|Robert/.test(&quot;Bob&quot;) //true/Bob|Robert/.test(&quot;Robert&quot;) //true/gray|grey/.test(&quot;gray&quot;) //true/gray|grey/.test(&quot;grey&quot;) //true/gr(a|e)y/.test(&quot;gray&quot;) //true/gr(a|e)y/.test(&quot;grey&quot;) //true/gr(aa|ee)y/.test(&quot;greey&quot;) //true/gr(aa|ee)y/.test(&quot;graay&quot;) //true |代表语句的或，多选语句可以包括多个字符但是需要再括号内否则意思就不一样例如下面的 12345678/^From|Subject|Date:*/.test(&quot;From&quot;) //true/^From|Subject|Date:*/.test(&quot;Subject&quot;) //true/^From|Subject|Date:*/.test(&quot;HSubject&quot;) //true/^(From|Subject|Date):*/.test(&quot;From&quot;) //false/^(From|Subject|Date):*/.test(&quot;Subject&quot;) //false/^(From|Subject|Date):*/.test(&quot;HSubject&quot;) //false/^(From|Subject|Date):*/.test(&quot;Subject:hello&quot;) //ture 注意：一个字符组可以匹配目标文本的单个字符，而多选结构可能是完整语句，可以匹配任意长度文本 忽略大小写12345/[Ff][Rr][Oo][Mm]/.test(&quot;from&quot;) //true/[Ff][Rr][Oo][Mm]/.test(&quot;From&quot;) //true/from/i.test(&quot;FROM&quot;) //true i不是正则表达式的一部分，是工具或者编程语言提供的相关性，表示忽略大小写。 可选量词1234567/colou?r/.test(&quot;color&quot;) //true/colou?r/.test(&quot;colour&quot;) //true/colou?r/.test(&quot;coloor&quot;) //false/col(ou)?r/.test(&quot;colr&quot;) //true/col(ou)?r/.test(&quot;colour&quot;) //true/col(ou)?r/.test(&quot;color&quot;) //false 表示容许出现？对应紧挨的字符（非其他字符），或者没有这个字符。 重复量词12345/ *hello +world */.test(&quot;hello world&quot;) //true/ *hello +world */.test(&quot; hello world &quot;) //true/ *hello +world */.test(&quot;helloworld&quot;) //false/ *hello +world +[0-9]+/.test(&quot;hello world 123&quot;) //true/ *hello +world +[0-9]+/.test(&quot;hello world&quot;) //false *代表紧挨的字符出现任意次数包含0次，也就是出现多次或者不出现都可以，？代表出现一次或不出现。+代表最少出现一次，如果没出现就不匹配报错。 重复期间12/[a-z][0-9]&#123;5,9&#125;/.test(&quot;a12345&quot;) //true/[a-z][0-9]&#123;5,9&#125;/.test(&quot;a1234&quot;) //false {,}代表重复次数的区间，其实？就是{0,1}重复区间 括号及反向查询当匹配中的分组有嵌套时，是从外向里匹配的，其次在由左向右匹配12345/^([0-9])\1[0-9]([0-9])\1&#123;2&#125;/.test(335933) //true/^([0-9])\1[0-9]([0-9])\1&#123;2&#125;/.test(335944) //false/^([0-9])\1[0-9]([0-9])\2&#123;2&#125;/.test(335777) //true/^(([a-z])3)\1k([A-Z])\2&#123;2&#125;/.test(&quot;a3a3kAaa&quot;) //true/^([a-z]3)\1k([A-Z])\2&#123;2&#125;/.test(&quot;a3a3kAAA&quot;) //true 转义符号123/.[a-z]/.test(&quot;1a&quot;) //true/\.[a-z]/.test(&quot;1a&quot;) //false/\.[a-z]/.test(&quot;.a&quot;) //true 正则表达式中很多元字符如.?*等,直接使用就是有语意的元字符，比如.代表任何匹配的字符，但是如果我只想匹匹配.或者？好怎么办，那么就需要加个\转义字符，让元字符失去特殊字符含义，只表示这是一个a-z字母数字一样的普通字符匹配，如果\后面跟的不是元字符需要根据具体版本而定，另外字符组内部的反斜杠也需要根据不同版本而定]]></content>
      <categories>
        <category>基础</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
</search>
